(function(c){var b=false;(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-base64",function(){return e()})}else{d.Base64=e()}}(this,function(){var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var e={encode:function(h){var f="";var p,n,l;var o,m,k,j;var g=0;do{p=h.charCodeAt(g++);n=h.charCodeAt(g++);l=h.charCodeAt(g++);o=p>>2;m=((p&3)<<4)|(n>>4);k=((n&15)<<2)|(l>>6);j=l&63;if(isNaN(n)){m=((p&3)<<4);k=j=64}else{if(isNaN(l)){j=64}}f=f+d.charAt(o)+d.charAt(m)+d.charAt(k)+d.charAt(j)}while(g<h.length);return f},decode:function(h){var f="";var p,n,l;var o,m,k,j;var g=0;h=h.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{o=d.indexOf(h.charAt(g++));m=d.indexOf(h.charAt(g++));k=d.indexOf(h.charAt(g++));j=d.indexOf(h.charAt(g++));p=(o<<2)|(m>>4);n=((m&15)<<4)|(k>>2);l=((k&3)<<6)|j;f=f+String.fromCharCode(p);if(k!=64){f=f+String.fromCharCode(n)}if(j!=64){f=f+String.fromCharCode(l)}}while(g<h.length);return f}};return e}));(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-sha1",function(){return e()})}else{d.SHA1=e()}}(this,function(){function f(C,u){C[u>>5]|=128<<(24-u%32);C[((u+64>>9)<<4)+15]=u;var D=new Array(80);var B=1732584193;var A=-271733879;var z=-1732584194;var y=271733878;var v=-1009589776;var q,o,E,s,r,p,n,m;for(q=0;q<C.length;q+=16){s=B;r=A;p=z;n=y;m=v;for(o=0;o<80;o++){if(o<16){D[o]=C[q+o]}else{D[o]=h(D[o-3]^D[o-8]^D[o-14]^D[o-16],1)}E=i(i(h(B,5),d(o,A,z,y)),i(i(v,D[o]),g(o)));v=y;y=z;z=h(A,30);A=B;B=E}B=i(B,s);A=i(A,r);z=i(z,p);y=i(y,n);v=i(v,m)}return[B,A,z,y,v]}function d(n,m,p,o){if(n<20){return(m&p)|((~m)&o)}if(n<40){return m^p^o}if(n<60){return(m&p)|(m&o)|(p&o)}return m^p^o}function g(m){return(m<20)?1518500249:(m<40)?1859775393:(m<60)?-1894007588:-899497514}function l(o,r){var q=j(o);if(q.length>16){q=f(q,o.length*8)}var m=new Array(16),p=new Array(16);for(var n=0;n<16;n++){m[n]=q[n]^909522486;p[n]=q[n]^1549556828}var s=f(m.concat(j(r)),512+r.length*8);return f(p.concat(s),512+160)}function i(m,p){var o=(m&65535)+(p&65535);var n=(m>>16)+(p>>16)+(o>>16);return(n<<16)|(o&65535)}function h(m,n){return(m<<n)|(m>>>(32-n))}function j(p){var o=[];var m=255;for(var n=0;n<p.length*8;n+=8){o[n>>5]|=(p.charCodeAt(n/8)&m)<<(24-n%32)}return o}function e(o){var p="";var m=255;for(var n=0;n<o.length*32;n+=8){p+=String.fromCharCode((o[n>>5]>>>(24-n%32))&m)}return p}function k(p){var o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var r="";var q,m;for(var n=0;n<p.length*4;n+=3){q=(((p[n>>2]>>8*(3-n%4))&255)<<16)|(((p[n+1>>2]>>8*(3-(n+1)%4))&255)<<8)|((p[n+2>>2]>>8*(3-(n+2)%4))&255);for(m=0;m<4;m++){if(n*8+m*6>p.length*32){r+="="}else{r+=o.charAt((q>>6*(3-m))&63)}}}return r}return{b64_hmac_sha1:function(m,n){return k(l(m,n))},b64_sha1:function(m){return k(f(j(m),m.length*8))},binb2str:e,core_hmac_sha1:l,str_hmac_sha1:function(m,n){return e(l(m,n))},str_sha1:function(m){return e(f(j(m),m.length*8))},}}));(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-md5",function(){return e()})}else{d.MD5=e()}}(this,function(m){var k=function(q,t){var s=(q&65535)+(t&65535);var r=(q>>16)+(t>>16)+(s>>16);return(r<<16)|(s&65535)};var o=function(q,r){return(q<<r)|(q>>>(32-r))};var d=function(s){var r=[];for(var q=0;q<s.length*8;q+=8){r[q>>5]|=(s.charCodeAt(q/8)&255)<<(q%32)}return r};var h=function(r){var s="";for(var q=0;q<r.length*32;q+=8){s+=String.fromCharCode((r[q>>5]>>>(q%32))&255)}return s};var p=function(s){var r="0123456789abcdef";var t="";for(var q=0;q<s.length*4;q++){t+=r.charAt((s[q>>2]>>((q%4)*8+4))&15)+r.charAt((s[q>>2]>>((q%4)*8))&15)}return t};var f=function(z,v,u,r,y,w){return k(o(k(k(v,z),k(r,w)),y),u)};var l=function(u,r,z,y,q,w,v){return f((r&z)|((~r)&y),u,r,q,w,v)};var e=function(u,r,z,y,q,w,v){return f((r&y)|(z&(~y)),u,r,q,w,v)};var n=function(u,r,z,y,q,w,v){return f(r^z^y,u,r,q,w,v)};var j=function(u,r,z,y,q,w,v){return f(z^(r|(~y)),u,r,q,w,v)};var g=function(B,v){B[v>>5]|=128<<((v)%32);B[(((v+64)>>>9)<<4)+14]=v;var A=1732584193;var z=-271733879;var y=-1732584194;var w=271733878;var u,t,s,q;for(var r=0;r<B.length;r+=16){u=A;t=z;s=y;q=w;A=l(A,z,y,w,B[r+0],7,-680876936);w=l(w,A,z,y,B[r+1],12,-389564586);y=l(y,w,A,z,B[r+2],17,606105819);z=l(z,y,w,A,B[r+3],22,-1044525330);A=l(A,z,y,w,B[r+4],7,-176418897);w=l(w,A,z,y,B[r+5],12,1200080426);y=l(y,w,A,z,B[r+6],17,-1473231341);z=l(z,y,w,A,B[r+7],22,-45705983);A=l(A,z,y,w,B[r+8],7,1770035416);w=l(w,A,z,y,B[r+9],12,-1958414417);y=l(y,w,A,z,B[r+10],17,-42063);z=l(z,y,w,A,B[r+11],22,-1990404162);A=l(A,z,y,w,B[r+12],7,1804603682);w=l(w,A,z,y,B[r+13],12,-40341101);y=l(y,w,A,z,B[r+14],17,-1502002290);z=l(z,y,w,A,B[r+15],22,1236535329);A=e(A,z,y,w,B[r+1],5,-165796510);w=e(w,A,z,y,B[r+6],9,-1069501632);y=e(y,w,A,z,B[r+11],14,643717713);z=e(z,y,w,A,B[r+0],20,-373897302);A=e(A,z,y,w,B[r+5],5,-701558691);w=e(w,A,z,y,B[r+10],9,38016083);y=e(y,w,A,z,B[r+15],14,-660478335);z=e(z,y,w,A,B[r+4],20,-405537848);A=e(A,z,y,w,B[r+9],5,568446438);w=e(w,A,z,y,B[r+14],9,-1019803690);y=e(y,w,A,z,B[r+3],14,-187363961);z=e(z,y,w,A,B[r+8],20,1163531501);A=e(A,z,y,w,B[r+13],5,-1444681467);w=e(w,A,z,y,B[r+2],9,-51403784);y=e(y,w,A,z,B[r+7],14,1735328473);z=e(z,y,w,A,B[r+12],20,-1926607734);A=n(A,z,y,w,B[r+5],4,-378558);w=n(w,A,z,y,B[r+8],11,-2022574463);y=n(y,w,A,z,B[r+11],16,1839030562);z=n(z,y,w,A,B[r+14],23,-35309556);A=n(A,z,y,w,B[r+1],4,-1530992060);w=n(w,A,z,y,B[r+4],11,1272893353);y=n(y,w,A,z,B[r+7],16,-155497632);z=n(z,y,w,A,B[r+10],23,-1094730640);A=n(A,z,y,w,B[r+13],4,681279174);w=n(w,A,z,y,B[r+0],11,-358537222);y=n(y,w,A,z,B[r+3],16,-722521979);z=n(z,y,w,A,B[r+6],23,76029189);A=n(A,z,y,w,B[r+9],4,-640364487);w=n(w,A,z,y,B[r+12],11,-421815835);y=n(y,w,A,z,B[r+15],16,530742520);z=n(z,y,w,A,B[r+2],23,-995338651);A=j(A,z,y,w,B[r+0],6,-198630844);w=j(w,A,z,y,B[r+7],10,1126891415);y=j(y,w,A,z,B[r+14],15,-1416354905);z=j(z,y,w,A,B[r+5],21,-57434055);A=j(A,z,y,w,B[r+12],6,1700485571);w=j(w,A,z,y,B[r+3],10,-1894986606);y=j(y,w,A,z,B[r+10],15,-1051523);z=j(z,y,w,A,B[r+1],21,-2054922799);A=j(A,z,y,w,B[r+8],6,1873313359);w=j(w,A,z,y,B[r+15],10,-30611744);y=j(y,w,A,z,B[r+6],15,-1560198380);z=j(z,y,w,A,B[r+13],21,1309151649);A=j(A,z,y,w,B[r+4],6,-145523070);w=j(w,A,z,y,B[r+11],10,-1120210379);y=j(y,w,A,z,B[r+2],15,718787259);z=j(z,y,w,A,B[r+9],21,-343485551);A=k(A,u);z=k(z,t);y=k(y,s);w=k(w,q)}return[A,z,y,w]};var i={hexdigest:function(q){return p(g(d(q),q.length*8))},hash:function(q){return h(g(d(q),q.length*8))}};return i}));(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-utils",function(){return e()})}else{d.stropheUtils=e()}}(this,function(){var d={utf16to8:function(h){var g,j;var f="";var e=h.length;for(g=0;g<e;g++){j=h.charCodeAt(g);if((j>=0)&&(j<=127)){f+=h.charAt(g)}else{if(j>2047){f+=String.fromCharCode(224|((j>>12)&15));f+=String.fromCharCode(128|((j>>6)&63));f+=String.fromCharCode(128|((j>>0)&63))}else{f+=String.fromCharCode(192|((j>>6)&31));f+=String.fromCharCode(128|((j>>0)&63))}}}return f},addCookies:function(h){var l,f,g,k,e,i,j;for(l in (h||{})){e="";i="";j="";f=h[l];g=typeof f=="object";k=escape(unescape(g?f.value:f));if(g){e=f.expires?";expires="+f.expires:"";i=f.domain?";domain="+f.domain:"";j=f.path?";path="+f.path:""}document.cookie=l+"="+k+e+i+j}}};return d}));(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-polyfill",[],function(){return e()})}else{return e()}}(this,function(){if(!Function.prototype.bind){Function.prototype.bind=function(h){var g=this;var f=Array.prototype.slice;var e=Array.prototype.concat;var d=f.call(arguments,1);return function(){return g.apply(h?h:this,e.call(d,f.call(arguments,0)))}}}if(!Array.isArray){Array.isArray=function(d){return Object.prototype.toString.call(d)==="[object Array]"}}if(!Array.prototype.indexOf){Array.prototype.indexOf=function(e){var d=this.length;var f=Number(arguments[1])||0;f=(f<0)?Math.ceil(f):Math.floor(f);if(f<0){f+=d}for(;f<d;f++){if(f in this&&this[f]===e){return f}}return -1}}}));(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-core",["strophe-sha1","strophe-base64","strophe-md5","strophe-utils","strophe-polyfill"],function(){return e.apply(this,arguments)})}else{var f=e(d.SHA1,d.Base64,d.MD5,d.stropheUtils);window.Strophe=f.Strophe;window.$build=f.$build;window.$iq=f.$iq;window.$msg=f.$msg;window.$pres=f.$pres;window.SHA1=f.SHA1;window.Base64=f.Base64;window.MD5=f.MD5;window.b64_hmac_sha1=f.SHA1.b64_hmac_sha1;window.b64_sha1=f.SHA1.b64_sha1;window.str_hmac_sha1=f.SHA1.str_hmac_sha1;window.str_sha1=f.SHA1.str_sha1}}(this,function(d,h,i,k){var g;function j(n,m){return new g.Builder(n,m)}function l(m){return new g.Builder("message",m)}function f(m){return new g.Builder("iq",m)}function e(m){return new g.Builder("presence",m)}g={VERSION:"1.2.8",NS:{HTTPBIND:"http://jabber.org/protocol/httpbind",BOSH:"urn:xmpp:xbosh",CLIENT:"jabber:client",AUTH:"jabber:iq:auth",ROSTER:"jabber:iq:roster",PROFILE:"jabber:iq:profile",DISCO_INFO:"http://jabber.org/protocol/disco#info",DISCO_ITEMS:"http://jabber.org/protocol/disco#items",MUC:"http://jabber.org/protocol/muc",SASL:"urn:ietf:params:xml:ns:xmpp-sasl",STREAM:"http://etherx.jabber.org/streams",FRAMING:"urn:ietf:params:xml:ns:xmpp-framing",BIND:"urn:ietf:params:xml:ns:xmpp-bind",SESSION:"urn:ietf:params:xml:ns:xmpp-session",VERSION:"jabber:iq:version",STANZAS:"urn:ietf:params:xml:ns:xmpp-stanzas",XHTML_IM:"http://jabber.org/protocol/xhtml-im",XHTML:"http://www.w3.org/1999/xhtml"},XHTML:{tags:["a","blockquote","br","cite","em","img","li","ol","p","span","strong","ul","body"],attributes:{"a":["href"],"blockquote":["style"],"br":[],"cite":["style"],"em":[],"img":["src","alt","style","height","width"],"li":["style"],"ol":["style"],"p":["style"],"span":["style"],"strong":[],"ul":["style"],"body":[]},css:["background-color","color","font-family","font-size","font-style","font-weight","margin-left","margin-right","text-align","text-decoration"],validTag:function(m){for(var n=0;n<g.XHTML.tags.length;n++){if(m==g.XHTML.tags[n]){return true}}return false},validAttribute:function(m,o){if(typeof g.XHTML.attributes[m]!=="undefined"&&g.XHTML.attributes[m].length>0){for(var n=0;n<g.XHTML.attributes[m].length;n++){if(o==g.XHTML.attributes[m][n]){return true}}}return false},validCSS:function(n){for(var m=0;m<g.XHTML.css.length;m++){if(n==g.XHTML.css[m]){return true}}return false}},Status:{ERROR:0,CONNECTING:1,CONNFAIL:2,AUTHENTICATING:3,AUTHFAIL:4,CONNECTED:5,DISCONNECTED:6,DISCONNECTING:7,ATTACHED:8,REDIRECT:9,CONNTIMEOUT:10},LogLevel:{DEBUG:0,INFO:1,WARN:2,ERROR:3,FATAL:4},ElementType:{NORMAL:1,TEXT:3,CDATA:4,FRAGMENT:11},TIMEOUT:1.1,SECONDARY_TIMEOUT:0.1,addNamespace:function(m,n){g.NS[m]=n},forEachChild:function(p,q,o){var n,m;for(n=0;n<p.childNodes.length;n++){m=p.childNodes[n];if(m.nodeType==g.ElementType.NORMAL&&(!q||this.isTagEqual(m,q))){o(m)}}},isTagEqual:function(n,m){return n.tagName==m},_xmlGenerator:null,_makeGenerator:function(){var m;if(document.implementation.createDocument===undefined||document.implementation.createDocument&&document.documentMode&&document.documentMode<10){m=this._getIEXmlDom();m.appendChild(m.createElement("strophe"))}else{m=document.implementation.createDocument("jabber:client","strophe",null)}return m},xmlGenerator:function(){if(!g._xmlGenerator){g._xmlGenerator=g._makeGenerator()}return g._xmlGenerator},_getIEXmlDom:function(){var n=null;var p=["Msxml2.DOMDocument.6.0","Msxml2.DOMDocument.5.0","Msxml2.DOMDocument.4.0","MSXML2.DOMDocument.3.0","MSXML2.DOMDocument","MSXML.DOMDocument","Microsoft.XMLDOM"];for(var o=0;o<p.length;o++){if(n===null){try{n=new ActiveXObject(p[o])}catch(m){n=null}}else{break}}return n},xmlElement:function(q){if(!q){return null}var s=g.xmlGenerator().createElement(q);var o,r,p;for(o=1;o<arguments.length;o++){var n=arguments[o];if(!n){continue}if(typeof(n)=="string"||typeof(n)=="number"){s.appendChild(g.xmlTextNode(n))}else{if(typeof(n)=="object"&&typeof(n.sort)=="function"){for(r=0;r<n.length;r++){var m=n[r];if(typeof(m)=="object"&&typeof(m.sort)=="function"&&m[1]!==undefined&&m[1]!==null){s.setAttribute(m[0],m[1])}}}else{if(typeof(n)=="object"){for(p in n){if(n.hasOwnProperty(p)){if(n[p]!==undefined&&n[p]!==null){s.setAttribute(p,n[p])}}}}}}}return s},xmlescape:function(m){m=m.replace(/\&/g,"&amp;");m=m.replace(/</g,"&lt;");m=m.replace(/>/g,"&gt;");m=m.replace(/'/g,"&apos;");m=m.replace(/"/g,"&quot;");return m},xmlunescape:function(m){m=m.replace(/\&amp;/g,"&");m=m.replace(/&lt;/g,"<");m=m.replace(/&gt;/g,">");m=m.replace(/&apos;/g,"'");m=m.replace(/&quot;/g,'"');return m},xmlTextNode:function(m){return g.xmlGenerator().createTextNode(m)},xmlHtmlNode:function(m){var n;if(window.DOMParser){var o=new DOMParser();n=o.parseFromString(m,"text/xml")}else{n=new ActiveXObject("Microsoft.XMLDOM");n.async="false";n.loadXML(m)}return n},getText:function(n){if(!n){return null}var o="";if(n.childNodes.length===0&&n.nodeType==g.ElementType.TEXT){o+=n.nodeValue}for(var m=0;m<n.childNodes.length;m++){if(n.childNodes[m].nodeType==g.ElementType.TEXT){o+=n.childNodes[m].nodeValue}}return g.xmlescape(o)},copyElement:function(o){var m,n;if(o.nodeType==g.ElementType.NORMAL){n=g.xmlElement(o.tagName);for(m=0;m<o.attributes.length;m++){n.setAttribute(o.attributes[m].nodeName,o.attributes[m].value)}for(m=0;m<o.childNodes.length;m++){n.appendChild(g.copyElement(o.childNodes[m]))}}else{if(o.nodeType==g.ElementType.TEXT){n=g.xmlGenerator().createTextNode(o.nodeValue)}}return n},createHtml:function(o){var r,n,p,y,m,x,t,u,w,q,s;if(o.nodeType==g.ElementType.NORMAL){y=o.nodeName.toLowerCase();if(g.XHTML.validTag(y)){try{n=g.xmlElement(y);for(r=0;r<g.XHTML.attributes[y].length;r++){m=g.XHTML.attributes[y][r];x=o.getAttribute(m);if(typeof x=="undefined"||x===null||x===""||x===false||x===0){continue}if(m=="style"&&typeof x=="object"){if(typeof x.cssText!="undefined"){x=x.cssText}}if(m=="style"){t=[];u=x.split(";");for(p=0;p<u.length;p++){w=u[p].split(":");q=w[0].replace(/^\s*/,"").replace(/\s*$/,"").toLowerCase();if(g.XHTML.validCSS(q)){s=w[1].replace(/^\s*/,"").replace(/\s*$/,"");t.push(q+": "+s)}}if(t.length>0){x=t.join("; ");n.setAttribute(m,x)}}else{n.setAttribute(m,x)}}for(r=0;r<o.childNodes.length;r++){n.appendChild(g.createHtml(o.childNodes[r]))}}catch(v){n=g.xmlTextNode("")}}else{n=g.xmlGenerator().createDocumentFragment();for(r=0;r<o.childNodes.length;r++){n.appendChild(g.createHtml(o.childNodes[r]))}}}else{if(o.nodeType==g.ElementType.FRAGMENT){n=g.xmlGenerator().createDocumentFragment();for(r=0;r<o.childNodes.length;r++){n.appendChild(g.createHtml(o.childNodes[r]))}}else{if(o.nodeType==g.ElementType.TEXT){n=g.xmlTextNode(o.nodeValue)}}}return n},escapeNode:function(m){if(typeof m!=="string"){return m}return m.replace(/^\s+|\s+$/g,"").replace(/\\/g,"\\5c").replace(/ /g,"\\20").replace(/\"/g,"\\22").replace(/\&/g,"\\26").replace(/\'/g,"\\27").replace(/\//g,"\\2f").replace(/:/g,"\\3a").replace(/</g,"\\3c").replace(/>/g,"\\3e").replace(/@/g,"\\40")},unescapeNode:function(m){if(typeof m!=="string"){return m}return m.replace(/\\20/g," ").replace(/\\22/g,'"').replace(/\\26/g,"&").replace(/\\27/g,"'").replace(/\\2f/g,"/").replace(/\\3a/g,":").replace(/\\3c/g,"<").replace(/\\3e/g,">").replace(/\\40/g,"@").replace(/\\5c/g,"\\")},getNodeFromJid:function(m){if(m.indexOf("@")<0){return null}return m.split("@")[0]},getDomainFromJid:function(m){var n=g.getBareJidFromJid(m);if(n.indexOf("@")<0){return n}else{var o=n.split("@");o.splice(0,1);return o.join("@")}},getResourceFromJid:function(m){var n=m.split("/");if(n.length<2){return null}n.splice(0,1);return n.join("/")},getBareJidFromJid:function(m){return m?m.split("/")[0]:null},log:function(n,m){return},debug:function(m){this.log(this.LogLevel.DEBUG,m)},info:function(m){this.log(this.LogLevel.INFO,m)},warn:function(m){this.log(this.LogLevel.WARN,m)},error:function(m){this.log(this.LogLevel.ERROR,m)},fatal:function(m){this.log(this.LogLevel.FATAL,m)},serialize:function(o){var m;if(!o){return null}if(typeof(o.tree)==="function"){o=o.tree()}var q=o.nodeName;var n,p;if(o.getAttribute("_realname")){q=o.getAttribute("_realname")}m="<"+q;for(n=0;n<o.attributes.length;n++){if(o.attributes[n].nodeName!="_realname"){m+=" "+o.attributes[n].nodeName+"='"+g.xmlescape(o.attributes[n].value)+"'"}}if(o.childNodes.length>0){m+=">";for(n=0;n<o.childNodes.length;n++){p=o.childNodes[n];switch(p.nodeType){case g.ElementType.NORMAL:m+=g.serialize(p);break;case g.ElementType.TEXT:m+=g.xmlescape(p.nodeValue);break;case g.ElementType.CDATA:m+="<![CDATA["+p.nodeValue+"]]>"}}m+="</"+q+">"}else{m+="/>"}return m},_requestId:0,_connectionPlugins:{},addConnectionPlugin:function(m,n){g._connectionPlugins[m]=n}};g.Builder=function(n,m){if(n=="presence"||n=="message"||n=="iq"){if(m&&!m.xmlns){m.xmlns=g.NS.CLIENT}else{if(!m){m={xmlns:g.NS.CLIENT}}}}this.nodeTree=g.xmlElement(n,m);this.node=this.nodeTree};g.Builder.prototype={tree:function(){return this.nodeTree},toString:function(){return g.serialize(this.nodeTree)},up:function(){this.node=this.node.parentNode;return this},attrs:function(n){for(var m in n){if(n.hasOwnProperty(m)){if(n[m]===undefined){this.node.removeAttribute(m)}else{this.node.setAttribute(m,n[m])}}}return this},c:function(n,m,o){var p=g.xmlElement(n,m,o);this.node.appendChild(p);if(typeof o!=="string"&&typeof o!=="number"){this.node=p}return this},cnode:function(o){var n;var q=g.xmlGenerator();try{n=(q.importNode!==undefined)}catch(p){n=false}var m=n?q.importNode(o,true):g.copyElement(o);this.node.appendChild(m);this.node=m;return this},t:function(m){var n=g.xmlTextNode(m);this.node.appendChild(n);return this},h:function(n){var m=document.createElement("body");m.innerHTML=n;var o=g.createHtml(m);while(o.childNodes.length>0){this.node.appendChild(o.childNodes[0])}return this}};g.Handler=function(q,p,n,o,s,r,m){this.handler=q;this.ns=p;this.name=n;this.type=o;this.id=s;this.options=m||{matchBare:false};if(!this.options.matchBare){this.options.matchBare=false}if(this.options.matchBare){this.from=r?g.getBareJidFromJid(r):null}else{this.from=r}this.user=true};g.Handler.prototype={isMatch:function(o){var q;var p=null;if(this.options.matchBare){p=g.getBareJidFromJid(o.getAttribute("from"))}else{p=o.getAttribute("from")}q=false;if(!this.ns){q=true}else{var n=this;g.forEachChild(o,null,function(r){if(r.getAttribute("xmlns")==n.ns){q=true}});q=q||o.getAttribute("xmlns")==this.ns}var m=o.getAttribute("type");if(q&&(!this.name||g.isTagEqual(o,this.name))&&(!this.type||(Array.isArray(this.type)?this.type.indexOf(m)!=-1:m==this.type))&&(!this.id||o.getAttribute("id")==this.id)&&(!this.from||p==this.from)){return true}return false},run:function(n){var m=null;try{m=this.handler(n)}catch(o){console.log("Strophe runing callbacks error: ",o.message);if(o.sourceURL){g.fatal("error: "+this.handler+" "+o.sourceURL+":"+o.line+" - "+o.name+": "+o.message)}else{if(o.fileName){if(typeof(console)!="undefined"){console.trace();console.error(this.handler," - error - ",o,o.message)}g.fatal("error: "+this.handler+" "+o.fileName+":"+o.lineNumber+" - "+o.name+": "+o.message)}else{g.fatal("error: "+o.message+"\n"+o.stack)}}throw o}return m},toString:function(){return"{Handler: "+this.handler+"("+this.name+","+this.id+","+this.ns+")}"}};g.TimedHandler=function(n,m){this.period=n;this.handler=m;this.lastCalled=new Date().getTime();this.user=true};g.TimedHandler.prototype={run:function(){this.lastCalled=new Date().getTime();return this.handler()},reset:function(){this.lastCalled=new Date().getTime()},toString:function(){return"{TimedHandler: "+this.handler+"("+this.period+")}"}};g.Connection=function(m,o){this.service=m;this.options=o||{};var r=this.options.protocol||"";if(m.indexOf("ws:")===0||m.indexOf("wss:")===0||r.indexOf("ws")===0){this._proto=new g.Websocket(this)}else{this._proto=new g.Bosh(this)}this.jid="";this.domain=null;this.features=null;this._sasl_data={};this.do_session=false;this.do_bind=false;this.timedHandlers=[];this.handlers=[];this.removeTimeds=[];this.removeHandlers=[];this.addTimeds=[];this.addHandlers=[];this._authentication={};this._idleTimeout=null;this._disconnectTimeout=null;this.authenticated=false;this.connected=false;this.disconnecting=false;this.do_authentication=true;this.paused=false;this.restored=false;this._data=[];this._uniqueId=0;this._sasl_success_handler=null;this._sasl_failure_handler=null;this._sasl_challenge_handler=null;this.maxRetries=5;this._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this),100);k.addCookies(this.options.cookies);for(var n in g._connectionPlugins){if(g._connectionPlugins.hasOwnProperty(n)){var q=g._connectionPlugins[n];var p=function(){};p.prototype=q;this[n]=new p();this[n].init(this)}}};g.Connection.prototype={reset:function(){this._proto._reset();this.do_session=false;this.do_bind=false;this.timedHandlers=[];this.handlers=[];this.removeTimeds=[];this.removeHandlers=[];this.addTimeds=[];this.addHandlers=[];this._authentication={};this.authenticated=false;this.connected=false;this.disconnecting=false;this.restored=false;this._data=[];this._requests=[];this._uniqueId=0},pause:function(){this.paused=true},setJid:function(m){this.jid=m;this.authzid=g.getBareJidFromJid(this.jid);this.authcid=g.getNodeFromJid(this.jid)},getJid:function(){return this.jid},resume:function(){this.paused=false},getUniqueId:function(n){var m="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(q){var p=Math.random()*16|0,o=q=="x"?p:p&3|8;return o.toString(16)});if(typeof(n)=="string"||typeof(n)=="number"){return m+":"+n}else{return m+""}},connect:function(o,p,s,r,q,m,n){this.jid=o;this.authzid=g.getBareJidFromJid(this.jid);this.authcid=n||g.getNodeFromJid(this.jid);this.pass=p;this.servtype="xmpp";this.connect_callback=s;this.disconnecting=false;this.connected=false;this.authenticated=false;this.restored=false;this.domain=g.getDomainFromJid(this.jid);this._changeConnectStatus(g.Status.CONNECTING,null);this._proto._connect(r,q,m)},attach:function(o,m,p,s,r,q,n){if(this._proto instanceof g.Bosh){this._proto._attach(o,m,p,s,r,q,n)}else{throw {name:"StropheSessionError",message:'The "attach" method can only be used with a BOSH connection.'}}},restore:function(n,q,p,o,m){if(this._sessionCachingSupported()){this._proto._restore(n,q,p,o,m)}else{throw {name:"StropheSessionError",message:'The "restore" method can only be used with a BOSH connection.'}}},_sessionCachingSupported:function(){if(this._proto instanceof g.Bosh){if(!JSON){return false}try{window.sessionStorage.setItem("_strophe_","_strophe_");window.sessionStorage.removeItem("_strophe_")}catch(m){return false}return true}return false},xmlInput:function(m){return},xmlOutput:function(m){return},rawInput:function(m){return},rawOutput:function(m){return},nextValidRid:function(m){return},send:function(n){if(n===null){return}if(typeof(n.sort)==="function"){for(var m=0;m<n.length;m++){this._queueData(n[m])}}else{if(typeof(n.tree)==="function"){this._queueData(n.tree())}else{this._queueData(n)}}this._proto._send()},flush:function(){clearTimeout(this._idleTimeout);this._onIdle()},sendIQ:function(n,t,o,r){var v=null;var q=this;if(typeof(n.tree)==="function"){n=n.tree()}var m=n.getAttribute("id");if(!m){m=this.getUniqueId("sendIQ");n.setAttribute("id",m)}var p=n.getAttribute("to");var s=this.jid;var u=this.addHandler(function(y){if(v){q.deleteTimedHandler(v)}var w=false;var z=y.getAttribute("from");if(z===p||(!p&&(z===g.getBareJidFromJid(s)||z===g.getDomainFromJid(s)||z===s))){w=true}if(!w){throw {name:"StropheError",message:"Got answer to IQ from wrong jid:"+z+"\nExpected jid: "+p}}var x=y.getAttribute("type");if(x=="result"){if(t){t(y)}}else{if(x=="error"){if(o){o(y)}}else{throw {name:"StropheError",message:"Got bad IQ type of "+x}}}},null,"iq",["error","result"],m);if(r){v=this.addTimedHandler(r,function(){q.deleteHandler(u);if(o){o(null)}return false})}this.send(n);return m},_queueData:function(m){if(m===null||!m.tagName||!m.childNodes){throw {name:"StropheError",message:"Cannot queue non-DOMElement."}}this._data.push(m)},_sendRestart:function(){this._data.push("restart");this._proto._sendRestart();this._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this),100)},addTimedHandler:function(o,n){var m=new g.TimedHandler(o,n);this.addTimeds.push(m);return m},deleteTimedHandler:function(m){this.removeTimeds.push(m)},addHandler:function(r,q,o,p,t,s,n){var m=new g.Handler(r,q,o,p,t,s,n);this.addHandlers.push(m);return m},deleteHandler:function(m){this.removeHandlers.push(m);var n=this.addHandlers.indexOf(m);if(n>=0){this.addHandlers.splice(n,1)}},disconnect:function(m){this._changeConnectStatus(g.Status.DISCONNECTING,m);g.info("Disconnect was called because: "+m);if(this.connected){var n=false;this.disconnecting=true;if(this.authenticated){n=e({xmlns:g.NS.CLIENT,type:"unavailable"})}this._disconnectTimeout=this._addSysTimedHandler(3000,this._onDisconnectTimeout.bind(this));this._proto._disconnect(n)}else{g.info("Disconnect was called before Strophe connected to the server");this._proto._abortAllRequests()}},_changeConnectStatus:function(m,r){for(var n in g._connectionPlugins){if(g._connectionPlugins.hasOwnProperty(n)){var p=this[n];if(p.statusChanged){try{p.statusChanged(m,r)}catch(o){g.error(""+n+" plugin caused an exception "+"changing status: "+o)}}}}if(this.connect_callback){try{this.connect_callback(m,r)}catch(q){g.error("User connection callback caused an "+"exception: "+q)}}},_doDisconnect:function(m){if(typeof this._idleTimeout=="number"){clearTimeout(this._idleTimeout)}if(this._disconnectTimeout!==null){this.deleteTimedHandler(this._disconnectTimeout);this._disconnectTimeout=null}g.info("_doDisconnect was called");this._proto._doDisconnect();this.authenticated=false;this.disconnecting=false;this.restored=false;this.handlers=[];this.timedHandlers=[];this.removeTimeds=[];this.removeHandlers=[];this.addTimeds=[];this.addHandlers=[];this._changeConnectStatus(g.Status.DISCONNECTED,m);this.connected=false},_dataRecv:function(t,u){g.info("_dataRecv called");var m=this._proto._reqToData(t);if(m===null){return}if(this.xmlInput!==g.Connection.prototype.xmlInput){if(m.nodeName===this._proto.strip&&m.childNodes.length){this.xmlInput(m.childNodes[0])}else{this.xmlInput(m)}}if(this.rawInput!==g.Connection.prototype.rawInput){if(u){this.rawInput(u)}else{this.rawInput(g.serialize(m))}}var p,n;while(this.removeHandlers.length>0){n=this.removeHandlers.pop();p=this.handlers.indexOf(n);if(p>=0){this.handlers.splice(p,1)}}while(this.addHandlers.length>0){this.handlers.push(this.addHandlers.pop())}if(this.disconnecting&&this._proto._emptyQueue()){this._doDisconnect();return}var r=m.getAttribute("type");var s,o;if(r!==null&&r=="terminate"){if(this.disconnecting){return}s=m.getAttribute("condition");o=m.getElementsByTagName("conflict");if(s!==null){if(s=="remote-stream-error"&&o.length>0){s="conflict"}this._changeConnectStatus(g.Status.CONNFAIL,s)}else{this._changeConnectStatus(g.Status.CONNFAIL,"unknown")}this._doDisconnect(s);return}var q=this;g.forEachChild(m,null,function(z){var w,x;x=q.handlers;q.handlers=[];for(w=0;w<x.length;w++){var v=x[w];try{if(v.isMatch(z)&&(q.authenticated||!v.user)){if(v.run(z)){q.handlers.push(v)}}else{q.handlers.push(v)}}catch(y){g.warn("Removing Strophe handlers due to uncaught exception: "+y.message)}}})},mechanisms:{},_connect_cb:function(u,x,v){g.info("_connect_cb was called");this.connected=true;var n;try{n=this._proto._reqToData(u)}catch(s){if(s!="badformat"){throw s}this._changeConnectStatus(g.Status.CONNFAIL,"bad-format");this._doDisconnect("bad-format")}if(!n){return}if(this.xmlInput!==g.Connection.prototype.xmlInput){if(n.nodeName===this._proto.strip&&n.childNodes.length){this.xmlInput(n.childNodes[0])}else{this.xmlInput(n)}}if(this.rawInput!==g.Connection.prototype.rawInput){if(v){this.rawInput(v)}else{this.rawInput(g.serialize(n))}}var o=this._proto._connect_cb(n);if(o===g.Status.CONNFAIL){return}this._authentication.sasl_scram_sha1=false;this._authentication.sasl_plain=false;this._authentication.sasl_digest_md5=false;this._authentication.sasl_anonymous=false;this._authentication.legacy_auth=false;var q;if(n.getElementsByTagNameNS){q=n.getElementsByTagNameNS(g.NS.STREAM,"features").length>0}else{q=n.getElementsByTagName("stream:features").length>0||n.getElementsByTagName("features").length>0}var w=n.getElementsByTagName("mechanism");var m=[];var p,r,t=false;if(!q){this._proto._no_auth_received(x);return}if(w.length>0){for(p=0;p<w.length;p++){r=g.getText(w[p]);if(this.mechanisms[r]){m.push(this.mechanisms[r])}}}this._authentication.legacy_auth=n.getElementsByTagName("auth").length>0;t=this._authentication.legacy_auth||m.length>0;if(!t){this._proto._no_auth_received(x);return}if(this.do_authentication!==false){this.authenticate(m)}},authenticate:function(n){var q;for(q=0;q<n.length-1;++q){var m=q;for(var p=q+1;p<n.length;++p){if(n[p].prototype.priority>n[m].prototype.priority){m=p}}if(m!=q){var s=n[q];n[q]=n[m];n[m]=s}}var r=false;for(q=0;q<n.length;++q){if(!n[q].prototype.test(this)){continue}this._sasl_success_handler=this._addSysHandler(this._sasl_success_cb.bind(this),null,"success",null,null);this._sasl_failure_handler=this._addSysHandler(this._sasl_failure_cb.bind(this),null,"failure",null,null);this._sasl_challenge_handler=this._addSysHandler(this._sasl_challenge_cb.bind(this),null,"challenge",null,null);this._sasl_mechanism=new n[q]();this._sasl_mechanism.onStart(this);var t=j("auth",{xmlns:g.NS.SASL,mechanism:this._sasl_mechanism.name});if(this._sasl_mechanism.isClientFirst){var o=this._sasl_mechanism.onChallenge(this,null);t.t(h.encode(o))}this.send(t.tree());r=true;break}if(!r){if(g.getNodeFromJid(this.jid)===null){this._changeConnectStatus(g.Status.CONNFAIL,"x-strophe-bad-non-anon-jid");this.disconnect("x-strophe-bad-non-anon-jid")}else{this._changeConnectStatus(g.Status.AUTHENTICATING,null);this._addSysHandler(this._auth1_cb.bind(this),null,null,null,"_auth_1");this.send(f({type:"get",to:this.domain,id:"_auth_1"}).c("query",{xmlns:g.NS.AUTH}).c("username",{}).t(g.getNodeFromJid(this.jid)).tree())}}},_sasl_challenge_cb:function(o){var n=h.decode(g.getText(o));var m=this._sasl_mechanism.onChallenge(this,n);var p=j("response",{xmlns:g.NS.SASL});if(m!==""){p.t(h.encode(m))}this.send(p.tree());return true},_auth1_cb:function(m){var n=f({type:"set",id:"_auth_2"}).c("query",{xmlns:g.NS.AUTH}).c("username",{}).t(g.getNodeFromJid(this.jid)).up().c("password").t(this.pass);if(!g.getResourceFromJid(this.jid)){this.jid=g.getBareJidFromJid(this.jid)+"/strophe"}n.up().c("resource",{}).t(g.getResourceFromJid(this.jid));this._addSysHandler(this._auth2_cb.bind(this),null,null,null,"_auth_2");this.send(n.tree());return false},_sasl_success_cb:function(o){if(this._sasl_data["server-signature"]){var m;var r=h.decode(g.getText(o));var q=/([a-z]+)=([^,]+)(,|$)/;var p=r.match(q);if(p[1]=="v"){m=p[2]}if(m!=this._sasl_data["server-signature"]){this.deleteHandler(this._sasl_failure_handler);this._sasl_failure_handler=null;if(this._sasl_challenge_handler){this.deleteHandler(this._sasl_challenge_handler);this._sasl_challenge_handler=null}this._sasl_data={};return this._sasl_failure_cb(null)}}g.info("SASL authentication succeeded.");if(this._sasl_mechanism){this._sasl_mechanism.onSuccess()}this.deleteHandler(this._sasl_failure_handler);this._sasl_failure_handler=null;if(this._sasl_challenge_handler){this.deleteHandler(this._sasl_challenge_handler);this._sasl_challenge_handler=null}var n=[];var s=function(t,u){while(t.length){this.deleteHandler(t.pop())}this._sasl_auth1_cb.bind(this)(u);return false};n.push(this._addSysHandler(function(t){s.bind(this)(n,t)}.bind(this),null,"stream:features",null,null));n.push(this._addSysHandler(function(t){s.bind(this)(n,t)}.bind(this),g.NS.STREAM,"features",null,null));this._sendRestart();return false},_sasl_auth1_cb:function(n){this.features=n;var m,p;for(m=0;m<n.childNodes.length;m++){p=n.childNodes[m];if(p.nodeName=="bind"){this.do_bind=true}if(p.nodeName=="session"){this.do_session=true}}if(!this.do_bind){this._changeConnectStatus(g.Status.AUTHFAIL,null);return false}else{this._addSysHandler(this._sasl_bind_cb.bind(this),null,null,null,"_bind_auth_2");var o=g.getResourceFromJid(this.jid);if(o){this.send(f({type:"set",id:"_bind_auth_2"}).c("bind",{xmlns:g.NS.BIND}).c("resource",{}).t(o).tree())}else{this.send(f({type:"set",id:"_bind_auth_2"}).c("bind",{xmlns:g.NS.BIND}).tree())}}return false},_sasl_bind_cb:function(m){if(m.getAttribute("type")=="error"){g.info("SASL binding failed.");var n=m.getElementsByTagName("conflict"),q;if(n.length>0){q="conflict"}this._changeConnectStatus(g.Status.AUTHFAIL,q);return false}var p=m.getElementsByTagName("bind");var o;if(p.length>0){o=p[0].getElementsByTagName("jid");if(o.length>0){this.jid=g.getText(o[0]);if(this.do_session){this._addSysHandler(this._sasl_session_cb.bind(this),null,null,null,"_session_auth_2");this.send(f({type:"set",id:"_session_auth_2"}).c("session",{xmlns:g.NS.SESSION}).tree())}else{this.authenticated=true;this._changeConnectStatus(g.Status.CONNECTED,null)}}}else{g.info("SASL binding failed.");this._changeConnectStatus(g.Status.AUTHFAIL,null);return false}},_sasl_session_cb:function(m){if(m.getAttribute("type")=="result"){this.authenticated=true;this._changeConnectStatus(g.Status.CONNECTED,null)}else{if(m.getAttribute("type")=="error"){g.info("Session creation failed.");this._changeConnectStatus(g.Status.AUTHFAIL,null);return false}}return false},_sasl_failure_cb:function(m){if(this._sasl_success_handler){this.deleteHandler(this._sasl_success_handler);this._sasl_success_handler=null}if(this._sasl_challenge_handler){this.deleteHandler(this._sasl_challenge_handler);this._sasl_challenge_handler=null}if(this._sasl_mechanism){this._sasl_mechanism.onFailure()}this._changeConnectStatus(g.Status.AUTHFAIL,null);return false},_auth2_cb:function(m){if(m.getAttribute("type")=="result"){this.authenticated=true;this._changeConnectStatus(g.Status.CONNECTED,null)}else{if(m.getAttribute("type")=="error"){this._changeConnectStatus(g.Status.AUTHFAIL,null);this.disconnect("authentication failed")}}return false},_addSysTimedHandler:function(o,n){var m=new g.TimedHandler(o,n);m.user=false;this.addTimeds.push(m);return m},_addSysHandler:function(q,p,n,o,r){var m=new g.Handler(q,p,n,o,r);m.user=false;this.addHandlers.push(m);return m},_onDisconnectTimeout:function(){g.info("_onDisconnectTimeout was called");this._changeConnectStatus(g.Status.CONNTIMEOUT,null);this._proto._onDisconnectTimeout();this._doDisconnect();return false},_onIdle:function(){var n,p,q,o;while(this.addTimeds.length>0){this.timedHandlers.push(this.addTimeds.pop())}while(this.removeTimeds.length>0){p=this.removeTimeds.pop();n=this.timedHandlers.indexOf(p);if(n>=0){this.timedHandlers.splice(n,1)}}var m=new Date().getTime();o=[];for(n=0;n<this.timedHandlers.length;n++){p=this.timedHandlers[n];if(this.authenticated||!p.user){q=p.lastCalled+p.period;if(q-m<=0){if(p.run()){o.push(p)}}else{o.push(p)}}}this.timedHandlers=o;clearTimeout(this._idleTimeout);this._proto._onIdle();if(this.connected){this._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this),100)}}};g.SASLMechanism=function(m,o,n){this.name=m;this.isClientFirst=o;this.priority=n};g.SASLMechanism.prototype={test:function(m){return true},onStart:function(m){this._connection=m},onChallenge:function(m,n){throw new Error("You should implement challenge handling!")},onFailure:function(){this._connection=null},onSuccess:function(){this._connection=null}};g.SASLAnonymous=function(){};g.SASLAnonymous.prototype=new g.SASLMechanism("ANONYMOUS",false,10);g.SASLAnonymous.prototype.test=function(m){return m.authcid===null};g.Connection.prototype.mechanisms[g.SASLAnonymous.prototype.name]=g.SASLAnonymous;g.SASLPlain=function(){};g.SASLPlain.prototype=new g.SASLMechanism("PLAIN",true,20);g.SASLPlain.prototype.test=function(m){return m.authcid!==null};g.SASLPlain.prototype.onChallenge=function(n){var m=n.authzid;m=m+"\u0000";m=m+n.authcid;m=m+"\u0000";m=m+n.pass;return k.utf16to8(m)};g.Connection.prototype.mechanisms[g.SASLPlain.prototype.name]=g.SASLPlain;g.SASLSHA1=function(){};g.SASLSHA1.prototype=new g.SASLMechanism("SCRAM-SHA-1",true,40);g.SASLSHA1.prototype.test=function(m){return m.authcid!==null};g.SASLSHA1.prototype.onChallenge=function(n,o,p){var q=p||i.hexdigest(Math.random()*1234567890);var m="n="+k.utf16to8(n.authcid);m+=",r=";m+=q;n._sasl_data.cnonce=q;n._sasl_data["client-first-message-bare"]=m;m="n,,"+m;this.onChallenge=function(A,J){var H,u,E,x,v,C,F,D,r;var s,B,G;var z="c=biws,";var y=A._sasl_data["client-first-message-bare"]+","+J+",";var I=A._sasl_data.cnonce;var w=/([a-z]+)=([^,]+)(,|$)/;while(J.match(w)){var t=J.match(w);J=J.replace(t[0],"");switch(t[1]){case"r":H=t[2];break;case"s":u=t[2];break;case"i":E=t[2];break}}if(H.substr(0,I.length)!==I){A._sasl_data={};return A._sasl_failure_cb()}z+="r="+H;y+=z;u=h.decode(u);u+="\x00\x00\x00\x01";r=k.utf16to8(A.pass);x=C=d.core_hmac_sha1(r,u);for(F=1;F<E;F++){v=d.core_hmac_sha1(r,d.binb2str(C));for(D=0;D<5;D++){x[D]^=v[D]}C=v}x=d.binb2str(x);s=d.core_hmac_sha1(x,"Client Key");B=d.str_hmac_sha1(x,"Server Key");G=d.core_hmac_sha1(d.str_sha1(d.binb2str(s)),y);A._sasl_data["server-signature"]=d.b64_hmac_sha1(B,y);for(D=0;D<5;D++){s[D]^=G[D]}z+=",p="+h.encode(d.binb2str(s));return z}.bind(this);return m};g.Connection.prototype.mechanisms[g.SASLSHA1.prototype.name]=g.SASLSHA1;g.SASLMD5=function(){};g.SASLMD5.prototype=new g.SASLMechanism("DIGEST-MD5",false,30);g.SASLMD5.prototype.test=function(m){return m.authcid!==null};g.SASLMD5.prototype._quote=function(m){return'"'+m.replace(/\\/g,"\\\\").replace(/"/g,'\\"')+'"'};g.SASLMD5.prototype.onChallenge=function(n,y,u){var o=/([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;var z=u||i.hexdigest(""+(Math.random()*1234567890));var v="";var A=null;var w="";var m="";var t;while(y.match(o)){t=y.match(o);y=y.replace(t[0],"");t[2]=t[2].replace(/^"(.+)"$/,"$1");switch(t[1]){case"realm":v=t[2];break;case"nonce":w=t[2];break;case"qop":m=t[2];break;case"host":A=t[2];break}}var s=n.servtype+"/"+n.domain;if(A!==null){s=s+"/"+A}var r=k.utf16to8(n.authcid+":"+v+":"+this._connection.pass);var q=i.hash(r)+":"+w+":"+z;var p="AUTHENTICATE:"+s;var x="";x+="charset=utf-8,";x+="username="+this._quote(k.utf16to8(n.authcid))+",";x+="realm="+this._quote(v)+",";x+="nonce="+this._quote(w)+",";x+="nc=00000001,";x+="cnonce="+this._quote(z)+",";x+="digest-uri="+this._quote(s)+",";x+="response="+i.hexdigest(i.hexdigest(q)+":"+w+":00000001:"+z+":auth:"+i.hexdigest(p))+",";x+="qop=auth";this.onChallenge=function(){return""};return x};g.Connection.prototype.mechanisms[g.SASLMD5.prototype.name]=g.SASLMD5;g.SASLOAuthBearer=function(){};g.SASLOAuthBearer.prototype=new g.SASLMechanism("OAUTHBEARER",true,50);g.SASLOAuthBearer.prototype.test=function(m){return m.authcid!==null};g.SASLOAuthBearer.prototype.onChallenge=function(n){var m="n,a=";m=m+n.authzid;m=m+",";m=m+"\u0001";m=m+"auth=Bearer ";m=m+n.pass;m=m+"\u0001";m=m+"\u0001";return k.utf16to8(m)};g.Connection.prototype.mechanisms[g.SASLOAuthBearer.prototype.name]=g.SASLOAuthBearer;g.SASLExternal=function(){};g.SASLExternal.prototype=new g.SASLMechanism("EXTERNAL",true,60);g.SASLExternal.prototype.onChallenge=function(m){return m.authcid===m.authzid?"":m.authzid};g.Connection.prototype.mechanisms[g.SASLExternal.prototype.name]=g.SASLExternal;return{Strophe:g,$build:j,$msg:l,$iq:f,$pres:e,SHA1:d,Base64:h,MD5:i,}}));(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-bosh",["strophe-core"],function(f){return e(f.Strophe,f.$build)})}else{return e(Strophe,$build)}}(this,function(f,e){f.Request=function(i,h,g,j){this.id=++f._requestId;this.xmlData=i;this.data=f.serialize(i);this.origFunc=h;this.func=h;this.rid=g;this.date=NaN;this.sends=j||0;this.abort=false;this.dead=null;this.age=function(){if(!this.date){return 0}var k=new Date();return(k-this.date)/1000};this.timeDead=function(){if(!this.dead){return 0}var k=new Date();return(k-this.dead)/1000};this.xhr=this._newXHR()};f.Request.prototype={getResponse:function(){var g=null;if(this.xhr.responseXML&&this.xhr.responseXML.documentElement){g=this.xhr.responseXML.documentElement;if(g.tagName=="parsererror"){f.error("invalid response received");f.error("responseText: "+this.xhr.responseText);f.error("responseXML: "+f.serialize(this.xhr.responseXML));throw"parsererror"}}else{if(this.xhr.responseText){f.error("invalid response received");f.error("responseText: "+this.xhr.responseText);throw"badformat"}}return g},_newXHR:function(){var g=null;if(window.XMLHttpRequest){g=new XMLHttpRequest();if(g.overrideMimeType){g.overrideMimeType("text/xml; charset=utf-8")}}else{if(window.ActiveXObject){g=new ActiveXObject("Microsoft.XMLHTTP")}}g.onreadystatechange=this.func.bind(null,this);return g}};f.Bosh=function(g){this._conn=g;this.rid=Math.floor(Math.random()*4294967295);this.sid=null;this.hold=1;this.wait=60;this.window=5;this.errors=0;this._requests=[]};f.Bosh.prototype={strip:null,_buildBody:function(){var g=e("body",{rid:this.rid++,xmlns:f.NS.HTTPBIND});if(this.sid!==null){g.attrs({sid:this.sid})}if(this._conn.options.keepalive&&this._conn._sessionCachingSupported()){this._cacheSession()}return g},_reset:function(){this.rid=Math.floor(Math.random()*4294967295);this.sid=null;this.errors=0;if(this._conn._sessionCachingSupported()){window.sessionStorage.removeItem("strophe-bosh-session")}this._conn.nextValidRid(this.rid)},_connect:function(k,j,h){this.wait=k||this.wait;this.hold=j||this.hold;this.errors=0;var g=this._buildBody().attrs({to:this._conn.domain,"xml:lang":"en",wait:this.wait,hold:this.hold,content:"text/xml; charset=utf-8",ver:"1.6","xmpp:version":"1.0","xmlns:xmpp":f.NS.BOSH});if(h){g.attrs({route:h})}var i=this._conn._connect_cb;this._requests.push(new f.Request(g.tree(),this._onRequestStateChange.bind(this,i.bind(this._conn)),g.tree().getAttribute("rid")));this._throttledRequestHandler()},_attach:function(i,g,j,m,l,k,h){this._conn.jid=i;this.sid=g;this.rid=j;this._conn.connect_callback=m;this._conn.domain=f.getDomainFromJid(this._conn.jid);this._conn.authenticated=true;this._conn.connected=true;this.wait=l||this.wait;this.hold=k||this.hold;this.window=h||this.window;this._conn._changeConnectStatus(f.Status.ATTACHED,null)},_restore:function(h,l,k,j,g){var i=JSON.parse(window.sessionStorage.getItem("strophe-bosh-session"));if(typeof i!=="undefined"&&i!==null&&i.rid&&i.sid&&i.jid&&(typeof h==="undefined"||h===null||f.getBareJidFromJid(i.jid)==f.getBareJidFromJid(h))){this._conn.restored=true;this._attach(i.jid,i.sid,i.rid,l,k,j,g)}else{throw {name:"StropheSessionError",message:"_restore: no restoreable session."}}},_cacheSession:function(){if(this._conn.authenticated){if(this._conn.jid&&this.rid&&this.sid){window.sessionStorage.setItem("strophe-bosh-session",JSON.stringify({"jid":this._conn.jid,"rid":this.rid,"sid":this.sid}))}}else{window.sessionStorage.removeItem("strophe-bosh-session")}},_connect_cb:function(h){var j=h.getAttribute("type");var i,k;if(j!==null&&j=="terminate"){i=h.getAttribute("condition");f.error("BOSH-Connection failed: "+i);k=h.getElementsByTagName("conflict");if(i!==null){if(i=="remote-stream-error"&&k.length>0){i="conflict"}this._conn._changeConnectStatus(f.Status.CONNFAIL,i)}else{this._conn._changeConnectStatus(f.Status.CONNFAIL,"unknown")}this._conn._doDisconnect(i);return f.Status.CONNFAIL}if(!this.sid){this.sid=h.getAttribute("sid")}var g=h.getAttribute("requests");if(g){this.window=parseInt(g,10)}var m=h.getAttribute("hold");if(m){this.hold=parseInt(m,10)}var l=h.getAttribute("wait");if(l){this.wait=parseInt(l,10)}},_disconnect:function(g){this._sendTerminate(g)},_doDisconnect:function(){this.sid=null;this.rid=Math.floor(Math.random()*4294967295);if(this._conn._sessionCachingSupported()){window.sessionStorage.removeItem("strophe-bosh-session")}this._conn.nextValidRid(this.rid)},_emptyQueue:function(){return this._requests.length===0},_hitError:function(g){this.errors++;f.warn("request errored, status: "+g+", number of errors: "+this.errors);if(this.errors>4){this._conn._onDisconnectTimeout()}},_no_auth_received:function(h){if(h){h=h.bind(this._conn)}else{h=this._conn._connect_cb.bind(this._conn)}var g=this._buildBody();this._requests.push(new f.Request(g.tree(),this._onRequestStateChange.bind(this,h.bind(this._conn)),g.tree().getAttribute("rid")));this._throttledRequestHandler()},_onDisconnectTimeout:function(){this._abortAllRequests()},_abortAllRequests:function d(){var g;while(this._requests.length>0){g=this._requests.pop();g.abort=true;g.xhr.abort();g.xhr.onreadystatechange=function(){}}},_onIdle:function(){var j=this._conn._data;if(this._conn.authenticated&&this._requests.length===0&&j.length===0&&!this._conn.disconnecting){f.info("no requests during idle cycle, sending "+"blank request");j.push(null)}if(this._conn.paused){return}if(this._requests.length<2&&j.length>0){var g=this._buildBody();for(var h=0;h<j.length;h++){if(j[h]!==null){if(j[h]==="restart"){g.attrs({to:this._conn.domain,"xml:lang":"en","xmpp:restart":"true","xmlns:xmpp":f.NS.BOSH})}else{g.cnode(j[h]).up()}}}delete this._conn._data;this._conn._data=[];this._requests.push(new f.Request(g.tree(),this._onRequestStateChange.bind(this,this._conn._dataRecv.bind(this._conn)),g.tree().getAttribute("rid")));this._throttledRequestHandler()}if(this._requests.length>0){var k=this._requests[0].age();if(this._requests[0].dead!==null){if(this._requests[0].timeDead()>Math.floor(f.SECONDARY_TIMEOUT*this.wait)){this._throttledRequestHandler()}}if(k>Math.floor(f.TIMEOUT*this.wait)){f.warn("Request "+this._requests[0].id+" timed out, over "+Math.floor(f.TIMEOUT*this.wait)+" seconds since last activity");this._throttledRequestHandler()}}},_onRequestStateChange:function(j,i){f.debug("request id "+i.id+"."+i.sends+" state changed to "+i.xhr.readyState);if(i.abort){i.abort=false;return}var h;if(i.xhr.readyState==4){h=0;try{h=i.xhr.status}catch(k){}if(typeof(h)=="undefined"){h=0}if(this.disconnecting){if(h>=400){this._hitError(h);return}}var g=(this._requests[0]==i);var l=(this._requests[1]==i);if((h>0&&h<500)||i.sends>5){this._removeRequest(i);f.debug("request id "+i.id+" should now be removed")}if(h==200){if(l||(g&&this._requests.length>0&&this._requests[0].age()>Math.floor(f.SECONDARY_TIMEOUT*this.wait))){this._restartRequest(0)}this._conn.nextValidRid(Number(i.rid)+1);f.debug("request id "+i.id+"."+i.sends+" got 200");j(i);this.errors=0}else{f.error("request id "+i.id+"."+i.sends+" error "+h+" happened");if(h===0||(h>=400&&h<600)||h>=12000){this._hitError(h);if(h>=400&&h<500){this._conn._changeConnectStatus(f.Status.DISCONNECTING,null);this._conn._doDisconnect()}}}if(!((h>0&&h<500)||i.sends>5)){this._throttledRequestHandler()}}},_processRequest:function(j){var t=this;var o=this._requests[j];var s=-1;try{if(o.xhr.readyState==4){s=o.xhr.status}}catch(m){f.error("caught an error in _requests["+j+"], reqStatus: "+s)}if(typeof(s)=="undefined"){s=-1}if(o.sends>this._conn.maxRetries){this._conn._onDisconnectTimeout();return}var h=o.age();var g=(!isNaN(h)&&h>Math.floor(f.TIMEOUT*this.wait));var k=(o.dead!==null&&o.timeDead()>Math.floor(f.SECONDARY_TIMEOUT*this.wait));var q=(o.xhr.readyState==4&&(s<1||s>=500));if(g||k||q){if(k){f.error("Request "+this._requests[j].id+" timed out (secondary), restarting")}o.abort=true;o.xhr.abort();o.xhr.onreadystatechange=function(){};this._requests[j]=new f.Request(o.xmlData,o.origFunc,o.rid,o.sends);o=this._requests[j]}if(o.xhr.readyState===0){f.debug("request id "+o.id+"."+o.sends+" posting");try{var r=this._conn.options.contentType||"text/xml; charset=utf-8";o.xhr.open("POST",this._conn.service,this._conn.options.sync?false:true);o.xhr.setRequestHeader&&o.xhr.setRequestHeader("Content-Type",r);if(this._conn.options.withCredentials){o.xhr.withCredentials=true}}catch(n){f.error("XHR open failed.");if(!this._conn.connected){this._conn._changeConnectStatus(f.Status.CONNFAIL,"bad-service")}this._conn.disconnect();return}var t=this;var p=function(){o.date=new Date();if(t._conn.options.customHeaders){var i=t._conn.options.customHeaders;for(var u in i){if(i.hasOwnProperty(u)){o.xhr.setRequestHeader(u,i[u])}}}window.XDomainRequest&&(o.xhr.readyState=2);o.xhr.send(o.data)};if(o.sends>1){var l=Math.min(Math.floor(f.TIMEOUT*this.wait),Math.pow(o.sends,3))*1000;setTimeout(function(){p()},l)}else{p()}o.sends++;if(this._conn.xmlOutput!==f.Connection.prototype.xmlOutput){if(o.xmlData.nodeName===this.strip&&o.xmlData.childNodes.length){this._conn.xmlOutput(o.xmlData.childNodes[0])}else{this._conn.xmlOutput(o.xmlData)}}if(this._conn.rawOutput!==f.Connection.prototype.rawOutput){this._conn.rawOutput(o.data)}}else{f.debug("_processRequest: "+(j===0?"first":"second")+" request has readyState of "+o.xhr.readyState)}},_removeRequest:function(h){f.debug("removing request");var g;for(g=this._requests.length-1;g>=0;g--){if(h==this._requests[g]){this._requests.splice(g,1)}}h.xhr.onreadystatechange=function(){};this._throttledRequestHandler()},_restartRequest:function(g){var h=this._requests[g];if(h.dead===null){h.dead=new Date()}this._processRequest(g)},_reqToData:function(g){try{return g.getResponse()}catch(h){if(h!="parsererror"){throw h}this._conn.disconnect("strophe-parsererror")}},_sendTerminate:function(i){f.info("_sendTerminate was called");var g=this._buildBody().attrs({type:"terminate"});if(i){g.cnode(i.tree())}var h=new f.Request(g.tree(),this._onRequestStateChange.bind(this,this._conn._dataRecv.bind(this._conn)),g.tree().getAttribute("rid"));this._requests.push(h);this._throttledRequestHandler()},_send:function(){clearTimeout(this._conn._idleTimeout);this._throttledRequestHandler();this._conn._idleTimeout=setTimeout(function(){this._onIdle()}.bind(this._conn),100)},_sendRestart:function(){this._throttledRequestHandler();clearTimeout(this._conn._idleTimeout)},_throttledRequestHandler:function(){if(!this._requests){f.debug("_throttledRequestHandler called with "+"undefined requests")}else{f.debug("_throttledRequestHandler called with "+this._requests.length+" requests")}if(!this._requests||this._requests.length===0){return}if(this._requests.length>0){this._processRequest(0)}if(this._requests.length>1&&Math.abs(this._requests[0].rid-this._requests[1].rid)<this.window){this._processRequest(1)}}};return f}));(function(d,e){if(typeof define==="function"&&define.amd&&b){define("strophe-websocket",["strophe-core"],function(f){return e(f.Strophe,f.$build)})}else{return e(Strophe,$build)}}(this,function(e,d){e.Websocket=function(h){this._conn=h;this.strip="wrapper";var f=h.service;if(f.indexOf("ws:")!==0&&f.indexOf("wss:")!==0){var g="";if(h.options.protocol==="ws"&&window.location.protocol!=="https:"){g+="ws"}else{g+="wss"}g+="://"+window.location.host;if(f.indexOf("/")!==0){g+=window.location.pathname+f}else{g+=f}h.service=g}};e.Websocket.prototype={_buildStream:function(){return d("open",{"xmlns":e.NS.FRAMING,"to":this._conn.domain,"version":"1.0"})},_check_streamerror:function(f,l){var o;if(f.getElementsByTagNameNS){o=f.getElementsByTagNameNS(e.NS.STREAM,"error")}else{o=f.getElementsByTagName("stream:error")}if(o.length===0){return false}var m=o[0];var g="";var p="";var n="urn:ietf:params:xml:ns:xmpp-streams";for(var j=0;j<m.childNodes.length;j++){var k=m.childNodes[j];if(k.getAttribute("xmlns")!==n){break}if(k.nodeName==="text"){p=k.textContent}else{g=k.nodeName}}var h="WebSocket stream error: ";if(g){h+=g}else{h+="unknown"}if(p){h+=" - "+g}e.error(h);this._conn._changeConnectStatus(l,g);this._conn._doDisconnect();return true},_reset:function(){return},_connect:function(){this._closeSocket();this.socket=new WebSocket(this._conn.service,"xmpp");this.socket.onopen=this._onOpen.bind(this);this.socket.onerror=this._onError.bind(this);this.socket.onclose=this._onClose.bind(this);this.socket.onmessage=this._connect_cb_wrapper.bind(this)},_connect_cb:function(g){var f=this._check_streamerror(g,e.Status.CONNFAIL);if(f){return e.Status.CONNFAIL}},_handleStreamStart:function(i){var g=false;var h=i.getAttribute("xmlns");if(typeof h!=="string"){g="Missing xmlns in <open />"}else{if(h!==e.NS.FRAMING){g="Wrong xmlns in <open />: "+h}}var f=i.getAttribute("version");if(typeof f!=="string"){g="Missing version in <open />"}else{if(f!=="1.0"){g="Wrong version in <open />: "+f}}if(g){this._conn._changeConnectStatus(e.Status.CONNFAIL,g);this._conn._doDisconnect();return false}return true},_connect_cb_wrapper:function(j){if(j.data.indexOf("<open ")===0||j.data.indexOf("<?xml")===0){var k=j.data.replace(/^(<\?.*?\?>\s*)*/,"");if(k===""){return}var h=new DOMParser().parseFromString(k,"text/xml").documentElement;this._conn.xmlInput(h);this._conn.rawInput(j.data);if(this._handleStreamStart(h)){this._connect_cb(h)}}else{if(j.data.indexOf("<close ")===0){this._conn.rawInput(j.data);this._conn.xmlInput(j);var f=j.getAttribute("see-other-uri");if(f){this._conn._changeConnectStatus(e.Status.REDIRECT,"Received see-other-uri, resetting connection");this._conn.reset();this._conn.service=f;this._connect()}else{this._conn._changeConnectStatus(e.Status.CONNFAIL,"Received closing stream");this._conn._doDisconnect()}}else{var g=this._streamWrap(j.data);var i=new DOMParser().parseFromString(g,"text/xml").documentElement;this.socket.onmessage=this._onMessage.bind(this);this._conn._connect_cb(i,null,j.data)}}},_disconnect:function(i){if(this.socket&&this.socket.readyState!==WebSocket.CLOSED){if(i){this._conn.send(i)}var h=d("close",{"xmlns":e.NS.FRAMING});this._conn.xmlOutput(h);var f=e.serialize(h);this._conn.rawOutput(f);try{this.socket.send(f)}catch(g){e.info("Couldn't send <close /> tag.")}}this._conn._doDisconnect()},_doDisconnect:function(){e.info("WebSockets _doDisconnect was called");this._closeSocket()},_streamWrap:function(f){return"<wrapper>"+f+"</wrapper>"},_closeSocket:function(){if(this.socket){try{this.socket.close()}catch(f){}}this.socket=null},_emptyQueue:function(){return true},_onClose:function(){if(this._conn.connected&&!this._conn.disconnecting){e.error("Websocket closed unexpectedly");this._conn._doDisconnect()}else{e.info("Websocket closed")}},_no_auth_received:function(f){e.error("Server did not send any auth methods");this._conn._changeConnectStatus(e.Status.CONNFAIL,"Server did not send any auth methods");if(f){f=f.bind(this._conn);f()}this._conn._doDisconnect()},_onDisconnectTimeout:function(){},_abortAllRequests:function(){},_onError:function(f){e.error("Websocket error "+f);this._conn._changeConnectStatus(e.Status.CONNFAIL,"The WebSocket connection could not be established or was disconnected.");this._disconnect()},_onIdle:function(){var g=this._conn._data;if(g.length>0&&!this._conn.paused){for(var f=0;f<g.length;f++){if(g[f]!==null){var h,j;if(g[f]==="restart"){h=this._buildStream().tree()}else{h=g[f]}j=e.serialize(h);this._conn.xmlOutput(h);this._conn.rawOutput(j);this.socket.send(j)}}this._conn._data=[]}},_onMessage:function(g){WebIM&&WebIM.config.isDebug&&e.info(WebIM.utils.ts()+"recv:",g.data);var f,h;var i='<close xmlns="urn:ietf:params:xml:ns:xmpp-framing" />';if(g.data===i){this._conn.rawInput(i);this._conn.xmlInput(g);if(!this._conn.disconnecting){this._conn._doDisconnect()}return}else{if(g.data.search("<open ")===0){f=new DOMParser().parseFromString(g.data,"text/xml").documentElement;if(!this._handleStreamStart(f)){return}}else{h=this._streamWrap(g.data);f=new DOMParser().parseFromString(h,"text/xml").documentElement}}if(this._check_streamerror(f,e.Status.ERROR)){return}if(this._conn.disconnecting&&f.firstChild.nodeName==="presence"&&f.firstChild.getAttribute("type")==="unavailable"){this._conn.xmlInput(f);this._conn.rawInput(e.serialize(f));return}this._conn._dataRecv(f,g.data)},_onOpen:function(){e.info("Websocket open");var g=this._buildStream();this._conn.xmlOutput(g.tree());var f=e.serialize(g);this._conn.rawOutput(f);this.socket.send(f)},_reqToData:function(f){return f},_send:function(){this._conn.flush()},_sendRestart:function(){clearTimeout(this._conn._idleTimeout);this._conn._onIdle.bind(this._conn)()}};return e}));(function(d){if(typeof define==="function"&&define.amd&&b){define("strophe",["strophe-core","strophe-bosh","strophe-websocket"],function(e){return e})}})(this);if(c){if(typeof define==="function"&&define.amd&&b){var a=c;if(typeof requirejs==="function"){requirejs(["strophe"],function(d){a(d.Strophe,d.$build,d.$msg,d.$iq,d.$pres)})}else{require(["strophe"],function(d){a(d.Strophe,d.$build,d.$msg,d.$iq,d.$pres)})}}else{return c(Strophe,$build,$msg,$iq,$pres)}}})(function(b,e,d,a,c){window.Strophe=b;window.$build=e;window.$msg=d;window.$iq=a;window.$pres=c});

(function webpackUniversalModuleDefinition (root, factory) { if (typeof exports === "object" && typeof module === "object") { module.exports = factory() } else { if (typeof define === "function" && define.amd) { define([], factory) } else { if (typeof exports === "object") { exports["WebIM"] = factory() } else { root["WebIM"] = factory() } } } })(this, function () { return (function (modules) { var installedModules = {}; function __webpack_require__ (moduleId) { if (installedModules[moduleId]) { return installedModules[moduleId].exports } var module = installedModules[moduleId] = { exports: {}, id: moduleId, loaded: false }; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.loaded = true; return module.exports } __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.p = ""; return __webpack_require__(0) })([(function (module, exports, __webpack_require__) { module.exports = __webpack_require__(1) }), (function (module, exports, __webpack_require__) { var _version = "1.4.13"; var _code = __webpack_require__(2).code; var _utils = __webpack_require__(3).utils; var _msg = __webpack_require__(4); var _message = _msg._msg; var _msgHash = {}; var Queue = __webpack_require__(39).Queue; var CryptoJS = __webpack_require__(5); var _ = __webpack_require__(40); var Strophe = window.Strophe; var isStropheLog; var stropheConn = null; window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL; var logMessage = function (message) { }; if (window.XDomainRequest) { } Strophe.Request.prototype._newXHR = function () { var xhr = _utils.xmlrequest(true); if (xhr.overrideMimeType) { xhr.overrideMimeType("text/xml") } xhr.onreadystatechange = this.func.bind(null, this); return xhr }; Strophe.Websocket.prototype._closeSocket = function () { if (this.socket) { var me = this; setTimeout(function () { try { me.socket.close() } catch (e) { } }, 0) } else { this.socket = null } }; Strophe.log = function (level, msg) { if (!isStropheLog) { return } switch (level) { case this.LogLevel.DEBUG: console.debug(msg); break; case this.LogLevel.INFO: console.info(msg); break; case this.LogLevel.WARN: console.warn(msg); break; case this.LogLevel.ERROR: case this.LogLevel.FATAL: console.error(msg); break; default: console.log(msg) }return }; Strophe.Websocket.prototype._onMessage = function (message) { logMessage(message); var data = message.data; if (data.indexOf("<jid>") > 0) { var start = data.indexOf("<jid>"), end = data.indexOf("</jid>"), data = data.substring(start + 5, end); stropheConn.setJid(data) } var elem, data; if (message.data.indexOf("<close ") === 0) { elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement; var see_uri = elem.getAttribute("see-other-uri"); if (see_uri) { this._conn._changeConnectStatus(Strophe.Status.REDIRECT, "Received see-other-uri, resetting connection"); this._conn.reset(); this._conn.service = see_uri; this._connect() } else { this._conn._doDisconnect("receive <close> from server") } return } else { if (message.data.search("<open ") === 0) { elem = new DOMParser().parseFromString(message.data, "text/xml").documentElement; if (!this._handleStreamStart(elem)) { return } } else { data = this._streamWrap(message.data); elem = new DOMParser().parseFromString(data, "text/xml").documentElement } } if (this._check_streamerror(elem, Strophe.Status.ERROR)) { return } if (this._conn.disconnecting && elem.firstChild.nodeName === "presence" && elem.firstChild.getAttribute("type") === "unavailable") { this._conn.xmlInput(elem); this._conn.rawInput(Strophe.serialize(elem)); return } this._conn._dataRecv(elem, message.data) }; var _listenNetwork = function (onlineCallback, offlineCallback) { if (window.addEventListener) { window.addEventListener("online", onlineCallback); window.addEventListener("offline", offlineCallback) } else { if (window.attachEvent) { if (document.body) { document.body.attachEvent("ononline", onlineCallback); document.body.attachEvent("onoffline", offlineCallback) } else { window.attachEvent("load", function () { document.body.attachEvent("ononline", onlineCallback); document.body.attachEvent("onoffline", offlineCallback) }) } } else { } } }; var _parseRoom = function (result) { var rooms = []; var items = result.getElementsByTagName("item"); if (items) { for (var i = 0;i < items.length;i++) { var item = items[i]; var roomJid = item.getAttribute("jid"); var tmp = roomJid.split("@")[0]; var room = { jid: roomJid, name: item.getAttribute("name"), roomId: tmp.split("_")[1] }; rooms.push(room) } } return rooms }; var _parseRoomOccupants = function (result) { var occupants = []; var items = result.getElementsByTagName("item"); if (items) { for (var i = 0;i < items.length;i++) { var item = items[i]; var room = { jid: item.getAttribute("jid"), name: item.getAttribute("name") }; occupants.push(room) } } return occupants }; var _parseResponseMessage = function (msginfo) { var parseMsgData = { errorMsg: true, data: [] }; var msgBodies = msginfo.getElementsByTagName("body"); if (msgBodies) { for (var i = 0;i < msgBodies.length;i++) { var msgBody = msgBodies[i]; var childNodes = msgBody.childNodes; if (childNodes && childNodes.length > 0) { var childNode = msgBody.childNodes[0]; if (childNode.nodeType == Strophe.ElementType.TEXT) { var jsondata = childNode.wholeText || childNode.nodeValue; jsondata = jsondata.replace("\n", "<br>"); try { var data = eval("(" + jsondata + ")"); parseMsgData.errorMsg = false; parseMsgData.data = [data] } catch (e) { } } } } var delayTags = msginfo.getElementsByTagName("delay"); if (delayTags && delayTags.length > 0) { var delayTag = delayTags[0]; var delayMsgTime = delayTag.getAttribute("stamp"); if (delayMsgTime) { parseMsgData.delayTimeStamp = delayMsgTime } } } else { var childrens = msginfo.childNodes; if (childrens && childrens.length > 0) { var child = msginfo.childNodes[0]; if (child.nodeType == Strophe.ElementType.TEXT) { try { var data = eval("(" + child.nodeValue + ")"); parseMsgData.errorMsg = false; parseMsgData.data = [data] } catch (e) { } } } } return parseMsgData }; var _parseNameFromJidFn = function (jid, domain) { domain = domain || ""; var tempstr = jid; var findex = tempstr.indexOf("_"); if (findex !== -1) { tempstr = tempstr.substring(findex + 1) } var atindex = tempstr.indexOf("@" + domain); if (atindex !== -1) { tempstr = tempstr.substring(0, atindex) } return tempstr }; var _parseFriend = function (queryTag, conn, from) { var rouster = []; var items = queryTag.getElementsByTagName("item"); if (items) { for (var i = 0;i < items.length;i++) { var item = items[i]; var jid = item.getAttribute("jid"); if (!jid) { continue } var subscription = item.getAttribute("subscription"); var friend = { subscription: subscription, jid: jid }; var ask = item.getAttribute("ask"); if (ask) { friend.ask = ask } var name = item.getAttribute("name"); if (name) { friend.name = name } else { var n = _parseNameFromJidFn(jid); friend.name = n } var groups = []; Strophe.forEachChild(item, "group", function (group) { groups.push(Strophe.getText(group)) }); friend.groups = groups; rouster.push(friend); if (conn && (subscription == "from") && !ask) { conn.subscribe({ toJid: jid, message: "[resp:true]" }) } if (conn && (subscription == "to")) { conn.subscribed({ toJid: jid }) } } } return rouster }; var _login = function (options, conn) { if (!options) { return } var accessToken = options.access_token || ""; if (accessToken == "") { var loginfo = _utils.stringify(options); conn.onError({ type: _code.WEBIM_CONNCTION_OPEN_USERGRID_ERROR, data: options }); return } conn.context.accessToken = options.access_token; conn.context.accessTokenExpires = options.expires_in; if (conn.isOpening() && conn.context.stropheConn) { stropheConn = conn.getStrophe() } else { if (conn.isOpened() && conn.context.stropheConn) { stropheConn = conn.getStrophe() } else { stropheConn = conn.getStrophe() } } var callback = function (status, msg) { _loginCallback(status, msg, conn) }; conn.context.stropheConn = stropheConn; if (conn.route) { stropheConn.connect(conn.context.jid, "$t$" + accessToken, callback, conn.wait, conn.hold, conn.route) } else { stropheConn.connect(conn.context.jid, "$t$" + accessToken, callback, conn.wait, conn.hold) } }; var _parseMessageType = function (msginfo) { var receiveinfo = msginfo.getElementsByTagName("received"), inviteinfo = msginfo.getElementsByTagName("invite"), deliveryinfo = msginfo.getElementsByTagName("delivery"), acked = msginfo.getElementsByTagName("acked"), error = msginfo.getElementsByTagName("error"), msgtype = "normal"; if (receiveinfo && receiveinfo.length > 0 && receiveinfo[0].namespaceURI === "urn:xmpp:receipts") { msgtype = "received" } else { if (inviteinfo && inviteinfo.length > 0) { msgtype = "invite" } else { if (deliveryinfo && deliveryinfo.length > 0) { msgtype = "delivery" } else { if (acked && acked.length) { msgtype = "acked" } else { if (error && error.length) { var errorItem = error[0], userMuted = errorItem.getElementsByTagName("user-muted"); if (userMuted && userMuted.length) { msgtype = "userMuted" } } } } } } return msgtype }; var _handleMessageQueue = function (conn) { for (var i in _msgHash) { if (_msgHash.hasOwnProperty(i)) { _msgHash[i].send(conn) } } }; var _loginCallback = function (status, msg, conn) { var conflict, error; if (msg === "conflict") { conflict = true; conn.close() } if (status == Strophe.Status.CONNFAIL) { error = { type: _code.WEBIM_CONNCTION_SERVER_CLOSE_ERROR, msg: msg, reconnect: true }; conflict && (error.conflict = true); conn.onError(error) } else { if (status == Strophe.Status.ATTACHED || status == Strophe.Status.CONNECTED) { conn.autoReconnectNumTotal = 0; conn.intervalId = setInterval(function () { conn.handelSendQueue() }, 100); var handleMessage = function (msginfo) { var delivery = msginfo.getElementsByTagName("delivery"); var acked = msginfo.getElementsByTagName("acked"); if (delivery.length) { conn.handleDeliveredMessage(msginfo); return true } if (acked.length) { conn.handleAckedMessage(msginfo); return true } var type = _parseMessageType(msginfo); switch (type) { case "received": conn.handleReceivedMessage(msginfo); return true; case "invite": conn.handleInviteMessage(msginfo); return true; case "delivery": conn.handleDeliveredMessage(msginfo); return true; case "acked": conn.handleAckedMessage(msginfo); return true; case "userMuted": conn.handleMutedMessage(msginfo); return true; default: conn.handleMessage(msginfo); return true } }; var handlePresence = function (msginfo) { conn.handlePresence(msginfo); return true }; var handlePing = function (msginfo) { conn.handlePing(msginfo); return true }; var handleIqRoster = function (msginfo) { conn.handleIqRoster(msginfo); return true }; var handleIqPrivacy = function (msginfo) { conn.handleIqPrivacy(msginfo); return true }; var handleIq = function (msginfo) { conn.handleIq(msginfo); return true }; conn.addHandler(handleMessage, null, "message", null, null, null); conn.addHandler(handlePresence, null, "presence", null, null, null); conn.addHandler(handlePing, "urn:xmpp:ping", "iq", "get", null, null); conn.addHandler(handleIqRoster, "jabber:iq:roster", "iq", "set", null, null); conn.addHandler(handleIqPrivacy, "jabber:iq:privacy", "iq", "set", null, null); conn.addHandler(handleIq, null, "iq", null, null, null); conn.registerConfrIQHandler && (conn.registerConfrIQHandler()); conn.context.status = _code.STATUS_OPENED; var supportRecMessage = [_code.WEBIM_MESSAGE_REC_TEXT, _code.WEBIM_MESSAGE_REC_EMOJI]; if (_utils.isCanDownLoadFile) { supportRecMessage.push(_code.WEBIM_MESSAGE_REC_PHOTO); supportRecMessage.push(_code.WEBIM_MESSAGE_REC_AUDIO_FILE) } var supportSedMessage = [_code.WEBIM_MESSAGE_SED_TEXT]; if (_utils.isCanUploadFile) { supportSedMessage.push(_code.WEBIM_MESSAGE_REC_PHOTO); supportSedMessage.push(_code.WEBIM_MESSAGE_REC_AUDIO_FILE) } conn.notifyVersion(); conn.retry && _handleMessageQueue(conn); conn.heartBeat(); conn.isAutoLogin && conn.setPresence(); console.log("conn", conn); try { if (conn.unSendMsgArr.length > 0) { console.log("unSendMesArr", conn.unSendMsgArr); for (var i in conn.unSendMsgArr) { var dom = conn.unSendMsgArr[i]; conn.sendCommand(dom); delete conn.unSendMsgArr[i] } } } catch (e) { console.error(e.message) } conn.offLineSendConnecting = false; conn.logOut = false; conn.onOpened({ canReceive: supportRecMessage, canSend: supportSedMessage, accessToken: conn.context.accessToken }) } else { if (status == Strophe.Status.DISCONNECTING) { if (conn.isOpened()) { conn.stopHeartBeat(); conn.context.status = _code.STATUS_CLOSING; error = { type: _code.WEBIM_CONNCTION_SERVER_CLOSE_ERROR, msg: msg, reconnect: true }; conflict && (error.conflict = true); conn.onError(error) } } else { if (status == Strophe.Status.DISCONNECTED) { if (!conn.isClosing() || conn.isOpened()) { if (conn.autoReconnectNumTotal < conn.autoReconnectNumMax) { conn.reconnect(!conn.isClosing()); return } else { error = { type: _code.WEBIM_CONNCTION_DISCONNECTED }; conn.onError(error) } } conn.context.status = _code.STATUS_CLOSED; conn.clear(); conn.onClosed() } else { if (status == Strophe.Status.AUTHFAIL) { error = { type: _code.WEBIM_CONNCTION_AUTH_ERROR }; conflict && (error.conflict = true); conn.onError(error); conn.clear() } else { if (status == Strophe.Status.ERROR) { conn.context.status = _code.STATUS_ERROR; error = { type: _code.WEBIM_CONNCTION_SERVER_ERROR }; conflict && (error.conflict = true); conn.onError(error) } } } } } } conn.context.status_now = status }; var _getJid = function (options, conn) { var jid = options.toJid || ""; if (jid === "") { var appKey = conn.context.appKey || ""; var toJid = appKey + "_" + options.to + "@" + conn.domain; if (options.resource) { toJid = toJid + "/" + options.resource } jid = toJid } return jid }; var _getJidByName = function (name, conn) { var options = { to: name }; return _getJid(options, conn) }; var _validCheck = function (options, conn) { options = options || {}; if (options.user == "") { conn.onError({ type: _code.WEBIM_CONNCTION_USER_NOT_ASSIGN_ERROR }); return false } var user = (options.user + "") || ""; var appKey = options.appKey || ""; var devInfos = appKey.split("#"); if (devInfos.length !== 2) { conn.onError({ type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR }); return false } var orgName = devInfos[0]; var appName = devInfos[1]; if (!orgName) { conn.onError({ type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR }); return false } if (!appName) { conn.onError({ type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR }); return false } var jid = appKey + "_" + user.toLowerCase() + "@" + conn.domain, resource = options.resource || "webim"; if (conn.isMultiLoginSessions) { resource += user + new Date().getTime() + Math.floor(Math.random().toFixed(6) * 1000000) } conn.context.jid = jid + "/" + resource; conn.context.userId = user; conn.context.appKey = appKey; conn.context.appName = appName; conn.context.orgName = orgName; return true }; var _getXmppUrl = function (baseUrl, https) { if (/^(ws|http)s?:\/\/?/.test(baseUrl)) { return baseUrl } var url = { prefix: "http", base: "://" + baseUrl, suffix: "/http-bind/" }; if (https && _utils.isSupportWss) { url.prefix = "wss"; url.suffix = "/ws/" } else { if (https) { url.prefix = "https" } else { if (window.WebSocket) { url.prefix = "ws"; url.suffix = "/ws/" } } } return url.prefix + url.base + url.suffix }; var connection = function (options) { if (!this instanceof connection) { return new connection(options) } var options = options || {}; this.isHttpDNS = options.isHttpDNS || false; this.isMultiLoginSessions = options.isMultiLoginSessions || false; this.wait = options.wait || 30; this.retry = options.retry || false; this.https = options.https && location.protocol === "https:"; this.url = _getXmppUrl(options.url, this.https); this.hold = options.hold || 1; this.route = options.route || null; this.domain = options.domain || "easemob.com"; this.inactivity = options.inactivity || 30; this.heartBeatWait = options.heartBeatWait || 4500; this.maxRetries = options.maxRetries || 5; this.isAutoLogin = options.isAutoLogin === false ? false : true; this.pollingTime = options.pollingTime || 800; this.stropheConn = false; this.autoReconnectNumMax = options.autoReconnectNumMax || 0; this.autoReconnectNumTotal = 0; this.autoReconnectInterval = options.autoReconnectInterval || 0; this.context = { status: _code.STATUS_INIT }; this.sendQueue = new Queue(); this.intervalId = null; this.apiUrl = options.apiUrl || ""; this.isWindowSDK = options.isWindowSDK || false; this.encrypt = options.encrypt || { encrypt: { type: "none" } }; this.delivery = options.delivery || false; this.user = ""; this.orgName = ""; this.appName = ""; this.token = ""; this.unSendMsgArr = []; this.dnsArr = ["https://rs.easemob.com", "https://rsbak.easemob.com", "http://182.92.174.78", "http://112.126.66.111"]; this.dnsIndex = 0; this.dnsTotal = this.dnsArr.length; this.restHosts = null; this.restIndex = 0; this.restTotal = 0; this.xmppHosts = null; this.xmppIndex = 0; this.xmppTotal = 0; this.groupOption = {}; isStropheLog = options.isStropheLog || false }; connection.prototype.registerUser = function (options) { if (location.protocol != "https:" && this.isHttpDNS) { this.dnsIndex = 0; this.getHttpDNS(options, "signup") } else { this.signup(options) } }; connection.prototype.handelSendQueue = function () { var options = this.sendQueue.pop(); if (options !== null) { this.sendReceiptsMessage(options) } }; connection.prototype.listen = function (options) { this.onOpened = options.onOpened || _utils.emptyfn; this.onClosed = options.onClosed || _utils.emptyfn; this.onTextMessage = options.onTextMessage || _utils.emptyfn; this.onEmojiMessage = options.onEmojiMessage || _utils.emptyfn; this.onPictureMessage = options.onPictureMessage || _utils.emptyfn; this.onAudioMessage = options.onAudioMessage || _utils.emptyfn; this.onVideoMessage = options.onVideoMessage || _utils.emptyfn; this.onFileMessage = options.onFileMessage || _utils.emptyfn; this.onLocationMessage = options.onLocationMessage || _utils.emptyfn; this.onCmdMessage = options.onCmdMessage || _utils.emptyfn; this.onPresence = options.onPresence || _utils.emptyfn; this.onRoster = options.onRoster || _utils.emptyfn; this.onError = options.onError || _utils.emptyfn; this.onReceivedMessage = options.onReceivedMessage || _utils.emptyfn; this.onInviteMessage = options.onInviteMessage || _utils.emptyfn; this.onDeliverdMessage = options.onDeliveredMessage || _utils.emptyfn; this.onReadMessage = options.onReadMessage || _utils.emptyfn; this.onMutedMessage = options.onMutedMessage || _utils.emptyfn; this.onOffline = options.onOffline || _utils.emptyfn; this.onOnline = options.onOnline || _utils.emptyfn; this.onConfirmPop = options.onConfirmPop || _utils.emptyfn; this.onCreateGroup = options.onCreateGroup || _utils.emptyfn; this.onUpdateMyGroupList = options.onUpdateMyGroupList || _utils.emptyfn; this.onUpdateMyRoster = options.onUpdateMyRoster || _utils.emptyfn; this.onBlacklistUpdate = options.onBlacklistUpdate || _utils.emptyfn; _listenNetwork(this.onOnline, this.onOffline) }; connection.prototype.heartBeat = function (forcing) { if (forcing !== true) { forcing = false } var me = this; var isNeed = !/^ws|wss/.test(me.url) || /mobile/.test(navigator.userAgent); if (this.heartBeatID || (!forcing && !isNeed)) { return } var options = { toJid: this.domain, type: "normal" }; this.heartBeatID = setInterval(function () { _utils.isSupportWss && me.ping(options) }, this.heartBeatWait) }; connection.prototype.stopHeartBeat = function () { if (typeof this.heartBeatID == "number") { this.heartBeatID = clearInterval(this.heartBeatID) } }; connection.prototype.sendReceiptsMessage = function (options) { var dom = $msg({ from: this.context.jid || "", to: this.domain, id: options.id || "" }).c("received", { xmlns: "urn:xmpp:receipts", id: options.id || "" }); this.sendCommand(dom.tree()) }; connection.prototype.cacheReceiptsMessage = function (options) { this.sendQueue.push(options) }; connection.prototype.getStrophe = function () { if (location.protocol != "https:" && this.isHttpDNS) { var url = ""; var host = this.xmppHosts[this.xmppIndex]; var domain = _utils.getXmlFirstChild(host, "domain"); var ip = _utils.getXmlFirstChild(host, "ip"); if (ip) { url = ip.textContent; var port = _utils.getXmlFirstChild(host, "port"); if (port.textContent != "80") { url += ":" + port.textContent } } else { url = domain.textContent } if (url != "") { var parter = /(.+\/\/).+(\/.+)/; this.url = this.url.replace(parter, "$1" + url + "$2") } } var stropheConn = new Strophe.Connection(this.url, { inactivity: this.inactivity, maxRetries: this.maxRetries, pollingTime: this.pollingTime }); return stropheConn }; connection.prototype.getHostsByTag = function (data, tagName) { var tag = _utils.getXmlFirstChild(data, tagName); if (!tag) { console.log(tagName + " hosts error"); return null } var hosts = tag.getElementsByTagName("hosts"); if (hosts.length == 0) { console.log(tagName + " hosts error2"); return null } return hosts[0].getElementsByTagName("host") }; connection.prototype.getRestFromHttpDNS = function (options, type) { if (this.restIndex > this.restTotal) { console.log("rest hosts all tried,quit"); return } var url = ""; var host = this.restHosts[this.restIndex]; var domain = _utils.getXmlFirstChild(host, "domain"); var ip = _utils.getXmlFirstChild(host, "ip"); if (ip) { var port = _utils.getXmlFirstChild(host, "port"); url = (location.protocol === "https:" ? "https:" : "http:") + "//" + ip.textContent + ":" + port.textContent } else { url = (location.protocol === "https:" ? "https:" : "http:") + "//" + domain.textContent } if (url != "") { this.apiUrl = url; options.apiUrl = url } if (type == "login") { this.login(options) } else { this.signup(options) } }; connection.prototype.getHttpDNS = function (options, type) { var self = this; var suc = function (data, xhr) { data = new DOMParser().parseFromString(data, "text/xml").documentElement; var restHosts = self.getHostsByTag(data, "rest"); if (!restHosts) { console.log("rest hosts error3"); return } self.restHosts = restHosts; self.restTotal = restHosts.length; var makeArray = function (obj) { return Array.prototype.slice.call(obj, 0) }; try { Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType } catch (e) { makeArray = function (obj) { var res = []; for (var i = 0, len = obj.length;i < len;i++) { res.push(obj[i]) } return res } } var xmppHosts = makeArray(self.getHostsByTag(data, "xmpp")); if (!xmppHosts) { console.log("xmpp hosts error3"); return } for (var i = 0;i < xmppHosts.length;i++) { var httpType = self.https ? "https" : "http"; if (_utils.getXmlFirstChild(xmppHosts[i], "protocol").textContent === httpType) { var currentPost = xmppHosts[i]; xmppHosts.splice(i, 1); xmppHosts.unshift(currentPost) } } self.xmppHosts = xmppHosts; self.xmppTotal = xmppHosts.length; self.getRestFromHttpDNS(options, type) }; var error = function (res, xhr, msg) { console.log("getHttpDNS error", res, msg); self.dnsIndex++; if (self.dnsIndex < self.dnsTotal) { self.getHttpDNS(options, type) } }; var options2 = { url: this.dnsArr[this.dnsIndex] + "/easemob/server.xml", dataType: "text", type: "GET", data: { app_key: encodeURIComponent(options.appKey) }, success: suc || _utils.emptyfn, error: error || _utils.emptyfn }; _utils.ajax(options2) }; connection.prototype.signup = function (options) { var self = this; var orgName = options.orgName || ""; var appName = options.appName || ""; var appKey = options.appKey || ""; var suc = options.success || EMPTYFN; var err = options.error || EMPTYFN; if (!orgName && !appName && appKey) { var devInfos = appKey.split("#"); if (devInfos.length === 2) { orgName = devInfos[0]; appName = devInfos[1] } } if (!orgName && !appName) { err({ type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR }); return } var error = function (res, xhr, msg) { if (location.protocol != "https:" && self.isHttpDNS) { if ((self.restIndex + 1) < self.restTotal) { self.restIndex++; self.getRestFromHttpDNS(options, "signup"); return } } self.clear(); err(res) }; var https = options.https || https; var apiUrl = options.apiUrl; var restUrl = apiUrl + "/" + orgName + "/" + appName + "/users"; var userjson = { username: options.username, password: options.password, nickname: options.nickname || "" }; var userinfo = _utils.stringify(userjson); var options2 = { url: restUrl, dataType: "json", data: userinfo, success: suc, error: error }; _utils.ajax(options2) }; connection.prototype.open = function (options) { console.log(8888888); var appkey = options.appKey, orgName = appkey.split("#")[0], appName = appkey.split("#")[1]; this.orgName = orgName; this.appName = appName; if (options.accessToken) { this.token = options.accessToken } if (options.xmppURL) { this.url = _getXmppUrl(options.xmppURL, this.https) } if (location.protocol != "https:" && this.isHttpDNS) { this.dnsIndex = 0; this.getHttpDNS(options, "login") } else { this.login(options) } }; connection.prototype.login = function (options) { this.user = options.user; var pass = _validCheck(options, this); if (!pass) { return } var conn = this; if (conn.isOpened()) { return } if (options.accessToken) { options.access_token = options.accessToken; conn.context.restTokenData = options; _login(options, conn) } else { var apiUrl = options.apiUrl; var userId = this.context.userId; var pwd = options.pwd || ""; var appName = this.context.appName; var orgName = this.context.orgName; var suc = function (data, xhr) { conn.context.status = _code.STATUS_DOLOGIN_IM; conn.context.restTokenData = data; if (options.success) { options.success(data) } conn.token = data.access_token; _login(data, conn) }; var error = function (res, xhr, msg) { if (options.error) { options.error() } if (location.protocol != "https:" && conn.isHttpDNS) { if ((conn.restIndex + 1) < conn.restTotal) { conn.restIndex++; conn.getRestFromHttpDNS(options, "login"); return } } conn.clear(); if (res.error && res.error_description) { conn.onError({ type: _code.WEBIM_CONNCTION_OPEN_USERGRID_ERROR, data: res, xhr: xhr }) } else { conn.onError({ type: _code.WEBIM_CONNCTION_OPEN_ERROR, data: res, xhr: xhr }) } }; this.context.status = _code.STATUS_DOLOGIN_USERGRID; var loginJson = { grant_type: "password", username: userId, password: pwd, timestamp: +new Date() }; var loginfo = _utils.stringify(loginJson); var options2 = { url: apiUrl + "/" + orgName + "/" + appName + "/token", dataType: "json", data: loginfo, success: suc || _utils.emptyfn, error: error || _utils.emptyfn }; _utils.ajax(options2) } }; connection.prototype.attach = function (options) { var pass = _validCheck(options, this); if (!pass) { return } options = options || {}; var accessToken = options.accessToken || ""; if (accessToken == "") { this.onError({ type: _code.WEBIM_CONNCTION_TOKEN_NOT_ASSIGN_ERROR }); return } var sid = options.sid || ""; if (sid === "") { this.onError({ type: _code.WEBIM_CONNCTION_SESSIONID_NOT_ASSIGN_ERROR }); return } var rid = options.rid || ""; if (rid === "") { this.onError({ type: _code.WEBIM_CONNCTION_RID_NOT_ASSIGN_ERROR }); return } var stropheConn = this.getStrophe(); this.context.accessToken = accessToken; this.context.stropheConn = stropheConn; this.context.status = _code.STATUS_DOLOGIN_IM; var conn = this; var callback = function (status, msg) { _loginCallback(status, msg, conn) }; var jid = this.context.jid; var wait = this.wait; var hold = this.hold; var wind = this.wind || 5; stropheConn.attach(jid, sid, rid, callback, wait, hold, wind) }; connection.prototype.close = function (reason) { this.logOut = true; this.stopHeartBeat(); var status = this.context.status; if (status == _code.STATUS_INIT) { return } if (this.isClosed() || this.isClosing()) { return } this.context.status = _code.STATUS_CLOSING; this.context.stropheConn.disconnect(reason) }; connection.prototype.addHandler = function (handler, ns, name, type, id, from, options) { this.context.stropheConn.addHandler(handler, ns, name, type, id, from, options) }; connection.prototype.notifyVersion = function (suc, fail) { var jid = _getJid({}, this); var dom = $iq({ from: this.context.jid || "", to: this.domain, type: "result" }).c("query", { xmlns: "jabber:iq:version" }).c("name").t("easemob").up().c("version").t(_version).up().c("os").t("webim"); var suc = suc || _utils.emptyfn; var error = fail || this.onError; var failFn = function (ele) { error({ type: _code.WEBIM_CONNCTION_NOTIFYVERSION_ERROR, data: ele }) }; this.context.stropheConn.sendIQ(dom.tree(), suc, failFn); return }; connection.prototype.handlePresence = function (msginfo) { if (this.isClosed()) { return } var from = msginfo.getAttribute("from") || ""; var to = msginfo.getAttribute("to") || ""; var type = msginfo.getAttribute("type") || ""; var presence_type = msginfo.getAttribute("presence_type") || ""; var fromUser = _parseNameFromJidFn(from); var toUser = _parseNameFromJidFn(to); var isCreate = false; var isMemberJoin = false; var isDecline = false; var isApply = false; var info = { from: fromUser, to: toUser, fromJid: from, toJid: to, type: type, chatroom: msginfo.getElementsByTagName("roomtype").length ? true : false }; var showTags = msginfo.getElementsByTagName("show"); if (showTags && showTags.length > 0) { var showTag = showTags[0]; info.show = Strophe.getText(showTag) } var statusTags = msginfo.getElementsByTagName("status"); if (statusTags && statusTags.length > 0) { var statusTag = statusTags[0]; info.status = Strophe.getText(statusTag); info.code = statusTag.getAttribute("code") } var priorityTags = msginfo.getElementsByTagName("priority"); if (priorityTags && priorityTags.length > 0) { var priorityTag = priorityTags[0]; info.priority = Strophe.getText(priorityTag) } var error = msginfo.getElementsByTagName("error"); if (error && error.length > 0) { var error = error[0]; info.error = { code: error.getAttribute("code") } } var destroy = msginfo.getElementsByTagName("destroy"); if (destroy && destroy.length > 0) { var destroy = destroy[0]; info.destroy = true; var reason = destroy.getElementsByTagName("reason"); if (reason && reason.length > 0) { info.reason = Strophe.getText(reason[0]) } } var members = msginfo.getElementsByTagName("item"); if (members && members.length > 0) { var member = members[0]; var role = member.getAttribute("role"); var jid = member.getAttribute("jid"); var affiliation = member.getAttribute("affiliation"); if (role == "none" && jid) { var kickedMember = _parseNameFromJidFn(jid); var actor = member.getElementsByTagName("actor")[0]; var actorNick = actor.getAttribute("nick"); info.actor = actorNick; info.kicked = kickedMember } if (role == "moderator" && info.code == "201") { if (affiliation === "owner") { info.type = "createGroupACK"; isCreate = true } } } var x = msginfo.getElementsByTagName("x"); if (x && x.length > 0) { var apply = x[0].getElementsByTagName("apply"); var accept = x[0].getElementsByTagName("accept"); var item = x[0].getElementsByTagName("item"); var decline = x[0].getElementsByTagName("decline"); var addAdmin = x[0].getElementsByTagName("add_admin"); var removeAdmin = x[0].getElementsByTagName("remove_admin"); var addMute = x[0].getElementsByTagName("add_mute"); var removeMute = x[0].getElementsByTagName("remove_mute"); if (apply && apply.length > 0) { isApply = true; info.toNick = apply[0].getAttribute("toNick"); info.type = "joinGroupNotifications"; var groupJid = apply[0].getAttribute("to"); var gid = groupJid.split("@")[0].split("_"); gid = gid[gid.length - 1]; info.gid = gid } else { if (accept && accept.length > 0) { info.type = "joinPublicGroupSuccess" } else { if (item && item.length > 0) { var affiliation = item[0].getAttribute("affiliation"), role = item[0].getAttribute("role"); if (affiliation == "member" || role == "participant") { isMemberJoin = true; info.mid = info.fromJid.split("/"); info.mid = info.mid[info.mid.length - 1]; info.type = "memberJoinPublicGroupSuccess"; var roomtype = msginfo.getElementsByTagName("roomtype"); if (roomtype && roomtype.length > 0) { var type = roomtype[0].getAttribute("type"); if (type == "chatroom") { info.type = "memberJoinChatRoomSuccess" } } } } else { if (decline && decline.length) { isDecline = true; var gid = decline[0].getAttribute("fromNick"); var owner = _parseNameFromJidFn(decline[0].getAttribute("from")); info.type = "joinPublicGroupDeclined"; info.owner = owner; info.gid = gid } else { if (addAdmin && addAdmin.length > 0) { var gid = _parseNameFromJidFn(addAdmin[0].getAttribute("mucjid")); var owner = _parseNameFromJidFn(addAdmin[0].getAttribute("from")); info.owner = owner; info.gid = gid; info.type = "addAdmin" } else { if (removeAdmin && removeAdmin.length > 0) { var gid = _parseNameFromJidFn(removeAdmin[0].getAttribute("mucjid")); var owner = _parseNameFromJidFn(removeAdmin[0].getAttribute("from")); info.owner = owner; info.gid = gid; info.type = "removeAdmin" } else { if (addMute && addMute.length > 0) { var gid = _parseNameFromJidFn(addMute[0].getAttribute("mucjid")); var owner = _parseNameFromJidFn(addMute[0].getAttribute("from")); info.owner = owner; info.gid = gid; info.type = "addMute" } else { if (removeMute && removeMute.length > 0) { var gid = _parseNameFromJidFn(removeMute[0].getAttribute("mucjid")); var owner = _parseNameFromJidFn(removeMute[0].getAttribute("from")); info.owner = owner; info.gid = gid; info.type = "removeMute" } } } } } } } } } if (info.chatroom) { info.presence_type = presence_type; info.original_type = info.type; var reflectUser = from.slice(from.lastIndexOf("/") + 1); if (reflectUser === this.context.userId) { if (info.type === "" && !info.code) { info.type = "joinChatRoomSuccess" } else { if (presence_type === "unavailable" || info.type === "unavailable") { if (!info.status) { info.type = "leaveChatRoom" } else { if (info.code == 110) { info.type = "leaveChatRoom" } else { if (info.error && info.error.code == 406) { info.type = "reachChatRoomCapacity" } } } } } } } else { info.presence_type = presence_type; info.original_type = type; if (/subscribe/.test(info.type)) { } else { if (type == "" && !info.status && !info.error && !isCreate && !isApply && !isMemberJoin && !isDecline) { console.log(2222222, msginfo, info, isApply) } else { if (presence_type === "unavailable" || type === "unavailable") { if (info.destroy) { info.type = "deleteGroupChat" } else { if (info.code == 307 || info.code == 321) { var nick = msginfo.getAttribute("nick"); if (!nick) { info.type = "leaveGroup" } else { info.type = "removedFromGroup" } } } } } } } this.onPresence(info, msginfo) }; connection.prototype.handlePing = function (e) { if (this.isClosed()) { return } var id = e.getAttribute("id"); var from = e.getAttribute("from"); var to = e.getAttribute("to"); var dom = $iq({ from: to, to: from, id: id, type: "result" }); this.sendCommand(dom.tree()) }; connection.prototype.handleIq = function (iq) { return true }; connection.prototype.handleIqPrivacy = function (msginfo) { var list = msginfo.getElementsByTagName("list"); if (list.length == 0) { return } this.getBlacklist() }; connection.prototype.handleIqRoster = function (e) { var id = e.getAttribute("id"); var from = e.getAttribute("from") || ""; var name = _parseNameFromJidFn(from); var curJid = this.context.jid; var curUser = this.context.userId; var iqresult = $iq({ type: "result", id: id, from: curJid }); this.sendCommand(iqresult.tree()); var msgBodies = e.getElementsByTagName("query"); if (msgBodies && msgBodies.length > 0) { var queryTag = msgBodies[0]; var rouster = _parseFriend(queryTag, this, from); this.onRoster(rouster) } return true }; connection.prototype.handleMessage = function (msginfo) { var self = this; if (this.isClosed()) { return } var id = msginfo.getAttribute("id") || ""; this.cacheReceiptsMessage({ id: id }); var parseMsgData = _parseResponseMessage(msginfo); if (parseMsgData.errorMsg) { this.handlePresence(msginfo); return } var error = msginfo.getElementsByTagName("error"); var errorCode = ""; var errorText = ""; var errorBool = false; if (error.length > 0) { errorBool = true; errorCode = error[0].getAttribute("code"); var textDOM = error[0].getElementsByTagName("text"); errorText = textDOM[0].textContent || textDOM[0].text } var msgDatas = parseMsgData.data; for (var i in msgDatas) { if (!msgDatas.hasOwnProperty(i)) { continue } var msg = msgDatas[i]; if (!msg.from || !msg.to) { continue } var from = (msg.from + "").toLowerCase(); var too = (msg.to + "").toLowerCase(); var extmsg = msg.ext || {}; var chattype = ""; var typeEl = msginfo.getElementsByTagName("roomtype"); if (typeEl.length) { chattype = typeEl[0].getAttribute("type") || "chat" } else { chattype = msginfo.getAttribute("type") || "chat" } var msgBodies = msg.bodies; if (!msgBodies || msgBodies.length == 0) { continue } var msgBody = msg.bodies[0]; var type = msgBody.type; var isCmdMsg = false; try { switch (type) { case "txt": var receiveMsg = msgBody.msg; if (self.encrypt.type === "base64") { receiveMsg = atob(receiveMsg) } else { if (self.encrypt.type === "aes") { var key = CryptoJS.enc.Utf8.parse(self.encrypt.key); var iv = CryptoJS.enc.Utf8.parse(self.encrypt.iv); var mode = self.encrypt.mode.toLowerCase(); var option = {}; if (mode === "cbc") { option = { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 } } else { if (mode === "ebc") { option = { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 } } } var encryptedBase64Str = receiveMsg; var decryptedData = CryptoJS.AES.decrypt(encryptedBase64Str, key, option); var decryptedStr = decryptedData.toString(CryptoJS.enc.Utf8); receiveMsg = decryptedStr } } var emojibody = _utils.parseTextMessage(receiveMsg, WebIM.Emoji); if (emojibody.isemoji) { var msg = { id: id, type: chattype, from: from, to: too, delay: parseMsgData.delayTimeStamp, data: emojibody.body, ext: extmsg }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; this.onEmojiMessage(msg) } else { var msg = { id: id, type: chattype, from: from, to: too, delay: parseMsgData.delayTimeStamp, data: receiveMsg, ext: extmsg }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; this.onTextMessage(msg) } break; case "img": var rwidth = 0; var rheight = 0; if (msgBody.size) { rwidth = msgBody.size.width; rheight = msgBody.size.height } var msg = { id: id, type: chattype, from: from, to: too, url: (location.protocol != "https:" && self.isHttpDNS) ? (self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9))) : msgBody.url, secret: msgBody.secret, filename: msgBody.filename, thumb: msgBody.thumb, thumb_secret: msgBody.thumb_secret, file_length: msgBody.file_length || "", width: rwidth, height: rheight, filetype: msgBody.filetype || "", accessToken: this.context.accessToken || "", ext: extmsg, delay: parseMsgData.delayTimeStamp }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; this.onPictureMessage(msg); break; case "audio": var msg = { id: id, type: chattype, from: from, to: too, url: (location.protocol != "https:" && self.isHttpDNS) ? (self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9))) : msgBody.url, secret: msgBody.secret, filename: msgBody.filename, length: msgBody.length || "", file_length: msgBody.file_length || "", filetype: msgBody.filetype || "", accessToken: this.context.accessToken || "", ext: extmsg, delay: parseMsgData.delayTimeStamp }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; this.onAudioMessage(msg); break; case "file": var msg = { id: id, type: chattype, from: from, to: too, url: (location.protocol != "https:" && self.isHttpDNS) ? (self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9))) : msgBody.url, secret: msgBody.secret, filename: msgBody.filename, file_length: msgBody.file_length, accessToken: this.context.accessToken || "", ext: extmsg, delay: parseMsgData.delayTimeStamp }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; this.onFileMessage(msg); break; case "loc": var msg = { id: id, type: chattype, from: from, to: too, addr: msgBody.addr, lat: msgBody.lat, lng: msgBody.lng, ext: extmsg, delay: parseMsgData.delayTimeStamp }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; this.onLocationMessage(msg); break; case "video": var msg = { id: id, type: chattype, from: from, to: too, url: (location.protocol != "https:" && self.isHttpDNS) ? (self.apiUrl + msgBody.url.substr(msgBody.url.indexOf("/", 9))) : msgBody.url, secret: msgBody.secret, filename: msgBody.filename, file_length: msgBody.file_length, accessToken: this.context.accessToken || "", ext: extmsg, delay: parseMsgData.delayTimeStamp }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; this.onVideoMessage(msg); break; case "cmd": var msg = { id: id, from: from, to: too, action: msgBody.action, ext: extmsg, delay: parseMsgData.delayTimeStamp }; !msg.delay && delete msg.delay; msg.error = errorBool; msg.errorText = errorText; msg.errorCode = errorCode; if (msgBody.action === "em_retrieve_dns") { isCmdMsg = true } if (msgBody.action.indexOf("em_") !== 0) { self.onCmdMessage(msg) } else { var ackMessage = new WebIM.message("read", self.getUniqueId()); ackMessage.set({ id: msg.id, to: msg.from, ext: { logo: "easemob" } }); self.send(ackMessage.body); self.handelSendQueue() } break }if (self.delivery) { var msgId = self.getUniqueId(); var bodyId = msg.id; var deliverMessage = new WebIM.message("delivery", msgId); deliverMessage.set({ id: bodyId, to: msg.from }); self.send(deliverMessage.body) } isCmdMsg && this.close() } catch (e) { this.onError({ type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR, data: e }) } } }; connection.prototype.handleDeliveredMessage = function (message) { var id = message.id; var body = message.getElementsByTagName("body"); var mid = 0; mid = body[0].innerHTML; var msg = { mid: mid }; this.onDeliverdMessage(msg); this.sendReceiptsMessage({ id: id }) }; connection.prototype.handleAckedMessage = function (message) { var id = message.id; var body = message.getElementsByTagName("body"); var mid = 0; mid = body[0].innerHTML; var msg = { mid: mid }; this.onReadMessage(msg); this.sendReceiptsMessage({ id: id }) }; connection.prototype.handleReceivedMessage = function (message) { try { var received = message.getElementsByTagName("received"); var mid = received[0].getAttribute("mid"); var body = message.getElementsByTagName("body"); var id = body[0].innerHTML; var msg = { mid: mid, id: id }; this.onReceivedMessage(msg) } catch (e) { this.onError({ type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR, data: e }) } var rcv = message.getElementsByTagName("received"), id, mid; if (rcv.length > 0) { if (rcv[0].childNodes && rcv[0].childNodes.length > 0) { id = rcv[0].childNodes[0].nodeValue } else { id = rcv[0].innerHTML || rcv[0].innerText } mid = rcv[0].getAttribute("mid") } if (_msgHash[id]) { try { _msgHash[id].msg.success instanceof Function && _msgHash[id].msg.success(id, mid) } catch (e) { this.onError({ type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR, data: e }) } delete _msgHash[id] } }; connection.prototype.handleInviteMessage = function (message) { var form = null; var invitemsg = message.getElementsByTagName("invite"); var reasonDom = message.getElementsByTagName("reason")[0]; var reasonMsg = reasonDom.textContent; var id = message.getAttribute("id") || ""; this.sendReceiptsMessage({ id: id }); if (invitemsg && invitemsg.length > 0) { var fromJid = invitemsg[0].getAttribute("from"); form = _parseNameFromJidFn(fromJid) } var xmsg = message.getElementsByTagName("x"); var roomid = null; if (xmsg && xmsg.length > 0) { for (var i = 0;i < xmsg.length;i++) { if ("jabber:x:conference" === xmsg[i].namespaceURI) { var roomjid = xmsg[i].getAttribute("jid"); roomid = _parseNameFromJidFn(roomjid) } } } this.onInviteMessage({ type: "invite", from: form, roomid: roomid, reason: reasonMsg }) }; connection.prototype.handleMutedMessage = function (message) { var id = message.id; this.onMutedMessage({ mid: id }) }; connection.prototype.sendCommand = function (dom, id) { if (this.isOpened()) { this.context.stropheConn.send(dom) } else { this.unSendMsgArr.push(dom); if (!this.offLineSendConnecting && !this.logOut) { this.offLineSendConnecting = true; this.reconnect() } this.onError({ type: _code.WEBIM_CONNCTION_DISCONNECTED, reconnect: true }) } }; connection.prototype.getUniqueId = function (prefix) { if (this.autoIncrement) { this.autoIncrement++ } else { this.autoIncrement = 1 } var cdate = new Date(); var offdate = new Date(2010, 1, 1); var offset = cdate.getTime() - offdate.getTime(); var hexd = parseFloat(offset).toString(16) + this.autoIncrement; if (typeof prefix === "string" || typeof prefix === "number") { return prefix + "_" + hexd } else { return "WEBIM_" + hexd } }; connection.prototype.send = function (messageSource) { var self = this; var message = messageSource; if (message.type === "txt") { if (this.encrypt.type === "base64") { message = _.clone(messageSource); message.msg = btoa(message.msg) } else { if (this.encrypt.type === "aes") { message = _.clone(messageSource); var key = CryptoJS.enc.Utf8.parse(this.encrypt.key); var iv = CryptoJS.enc.Utf8.parse(this.encrypt.iv); var mode = this.encrypt.mode.toLowerCase(); var option = {}; if (mode === "cbc") { option = { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 } } else { if (mode === "ebc") { option = { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 } } } var encryptedData = CryptoJS.AES.encrypt(message.msg, key, option); message.msg = encryptedData.toString() } } } if (this.isWindowSDK) { WebIM.doQuery('{"type":"sendMessage","to":"' + message.to + '","message_type":"' + message.type + '","msg":"' + encodeURI(message.msg) + '","chatType":"' + message.chatType + '"}', function (response) { }, function (code, msg) { var message = { data: { data: "send" }, type: _code.WEBIM_MESSAGE_SED_ERROR }; self.onError(message) }) } else { if (Object.prototype.toString.call(message) === "[object Object]") { var appKey = this.context.appKey || ""; var toJid = appKey + "_" + message.to + "@" + this.domain; if (message.group) { toJid = appKey + "_" + message.to + "@conference." + this.domain } if (message.resource) { toJid = toJid + "/" + message.resource } message.toJid = toJid; message.id = message.id || this.getUniqueId(); _msgHash[message.id] = new _message(message); _msgHash[message.id].send(this) } else { if (typeof message === "string") { _msgHash[message] && _msgHash[message].send(this) } } } }; connection.prototype.addRoster = function (options) { var jid = _getJid(options, this); var name = options.name || ""; var groups = options.groups || ""; var iq = $iq({ type: "set" }); iq.c("query", { xmlns: "jabber:iq:roster" }); iq.c("item", { jid: jid, name: name }); if (groups) { for (var i = 0;i < groups.length;i++) { iq.c("group").t(groups[i]).up() } } var suc = options.success || _utils.emptyfn; var error = options.error || _utils.emptyfn; this.context.stropheConn.sendIQ(iq.tree(), suc, error) }; connection.prototype.removeRoster = function (options) { var jid = _getJid(options, this); var iq = $iq({ type: "set" }).c("query", { xmlns: "jabber:iq:roster" }).c("item", { jid: jid, subscription: "remove" }); var suc = options.success || _utils.emptyfn; var error = options.error || _utils.emptyfn; this.context.stropheConn.sendIQ(iq, suc, error) }; connection.prototype.getRoster = function (options) { var conn = this; var dom = $iq({ type: "get" }).c("query", { xmlns: "jabber:iq:roster" }); var options = options || {}; var suc = options.success || this.onRoster; var completeFn = function (ele) { var rouster = []; var msgBodies = ele.getElementsByTagName("query"); if (msgBodies && msgBodies.length > 0) { var queryTag = msgBodies[0]; rouster = _parseFriend(queryTag) } suc(rouster, ele) }; var error = options.error || this.onError; var failFn = function (ele) { error({ type: _code.WEBIM_CONNCTION_GETROSTER_ERROR, data: ele }) }; if (this.isOpened()) { this.context.stropheConn.sendIQ(dom.tree(), completeFn, failFn) } else { error({ type: _code.WEBIM_CONNCTION_DISCONNECTED }) } }; connection.prototype.subscribe = function (options) { var jid = _getJid(options, this); var pres = $pres({ to: jid, type: "subscribe" }); if (options.message) { pres.c("status").t(options.message).up() } if (options.nick) { pres.c("nick", { "xmlns": "http://jabber.org/protocol/nick" }).t(options.nick) } this.sendCommand(pres.tree()) }; connection.prototype.subscribed = function (options) { var jid = _getJid(options, this); var pres = $pres({ to: jid, type: "subscribed" }); if (options.message) { pres.c("status").t(options.message).up() } this.sendCommand(pres.tree()) }; connection.prototype.unsubscribe = function (options) { var jid = _getJid(options, this); var pres = $pres({ to: jid, type: "unsubscribe" }); if (options.message) { pres.c("status").t(options.message) } this.sendCommand(pres.tree()) }; connection.prototype.unsubscribed = function (options) { var jid = _getJid(options, this); var pres = $pres({ to: jid, type: "unsubscribed" }); if (options.message) { pres.c("status").t(options.message).up() } this.sendCommand(pres.tree()) }; connection.prototype.joinPublicGroup = function (options) { var roomJid = this.context.appKey + "_" + options.roomId + "@conference." + this.domain; var room_nick = roomJid + "/" + this.context.userId; var suc = options.success || _utils.emptyfn; var err = options.error || _utils.emptyfn; var errorFn = function (ele) { err({ type: _code.WEBIM_CONNCTION_JOINROOM_ERROR, data: ele }) }; var iq = $pres({ from: this.context.jid, to: room_nick }).c("x", { xmlns: Strophe.NS.MUC }); this.context.stropheConn.sendIQ(iq.tree(), suc, errorFn) }; connection.prototype.listRooms = function (options) { var iq = $iq({ to: options.server || "conference." + this.domain, from: this.context.jid, type: "get" }).c("query", { xmlns: Strophe.NS.DISCO_ITEMS }); var suc = options.success || _utils.emptyfn; var error = options.error || this.onError; var completeFn = function (result) { var rooms = []; rooms = _parseRoom(result); try { suc(rooms) } catch (e) { error({ type: _code.WEBIM_CONNCTION_GETROOM_ERROR, data: e }) } }; var err = options.error || _utils.emptyfn; var errorFn = function (ele) { err({ type: _code.WEBIM_CONNCTION_GETROOM_ERROR, data: ele }) }; this.context.stropheConn.sendIQ(iq.tree(), completeFn, errorFn) }; connection.prototype.queryRoomMember = function (options) { var domain = this.domain; var members = []; var iq = $iq({ to: this.context.appKey + "_" + options.roomId + "@conference." + this.domain, type: "get" }).c("query", { xmlns: Strophe.NS.MUC + "#admin" }).c("item", { affiliation: "member" }); var suc = options.success || _utils.emptyfn; var completeFn = function (result) { var items = result.getElementsByTagName("item"); if (items) { for (var i = 0;i < items.length;i++) { var item = items[i]; var mem = { jid: item.getAttribute("jid"), affiliation: "member" }; members.push(mem) } } suc(members) }; var err = options.error || _utils.emptyfn; var errorFn = function (ele) { err({ type: _code.WEBIM_CONNCTION_GETROOMMEMBER_ERROR, data: ele }) }; this.context.stropheConn.sendIQ(iq.tree(), completeFn, errorFn) }; connection.prototype.queryRoomInfo = function (options) { var domain = this.domain; var iq = $iq({ to: this.context.appKey + "_" + options.roomId + "@conference." + domain, type: "get" }).c("query", { xmlns: Strophe.NS.DISCO_INFO }); var suc = options.success || _utils.emptyfn; var members = []; var completeFn = function (result) { var settings = ""; var features = result.getElementsByTagName("feature"); if (features) { settings = features[1].getAttribute("var") + "|" + features[3].getAttribute("var") + "|" + features[4].getAttribute("var") } switch (settings) { case "muc_public|muc_membersonly|muc_notallowinvites": settings = "PUBLIC_JOIN_APPROVAL"; break; case "muc_public|muc_open|muc_notallowinvites": settings = "PUBLIC_JOIN_OPEN"; break; case "muc_hidden|muc_membersonly|muc_allowinvites": settings = "PRIVATE_MEMBER_INVITE"; break; case "muc_hidden|muc_membersonly|muc_notallowinvites": settings = "PRIVATE_OWNER_INVITE"; break }var owner = ""; var fields = result.getElementsByTagName("field"); var fieldValues = {}; if (fields) { for (var i = 0;i < fields.length;i++) { var field = fields[i]; var fieldVar = field.getAttribute("var"); var fieldSimplify = fieldVar.split("_")[1]; switch (fieldVar) { case "muc#roominfo_occupants": case "muc#roominfo_maxusers": case "muc#roominfo_affiliations": case "muc#roominfo_description": fieldValues[fieldSimplify] = (field.textContent || field.text || ""); break; case "muc#roominfo_owner": var mem = { jid: (field.textContent || field.text) + "@" + domain, affiliation: "owner" }; members.push(mem); fieldValues[fieldSimplify] = (field.textContent || field.text); break } } fieldValues["name"] = (result.getElementsByTagName("identity")[0]).getAttribute("name") } suc(settings, members, fieldValues) }; var err = options.error || _utils.emptyfn; var errorFn = function (ele) { err({ type: _code.WEBIM_CONNCTION_GETROOMINFO_ERROR, data: ele }) }; this.context.stropheConn.sendIQ(iq.tree(), completeFn, errorFn) }; connection.prototype.queryRoomOccupants = function (options) { var suc = options.success || _utils.emptyfn; var completeFn = function (result) { var occupants = []; occupants = _parseRoomOccupants(result); suc(occupants) }; var err = options.error || _utils.emptyfn; var errorFn = function (ele) { err({ type: _code.WEBIM_CONNCTION_GETROOMOCCUPANTS_ERROR, data: ele }) }; var attrs = { xmlns: Strophe.NS.DISCO_ITEMS }; var info = $iq({ from: this.context.jid, to: this.context.appKey + "_" + options.roomId + "@conference." + this.domain, type: "get" }).c("query", attrs); this.context.stropheConn.sendIQ(info.tree(), completeFn, errorFn) }; connection.prototype.setUserSig = function (desc) { var dom = $pres({ xmlns: "jabber:client" }); desc = desc || ""; dom.c("status").t(desc); this.sendCommand(dom.tree()) }; connection.prototype.setPresence = function (type, status) { var dom = $pres({ xmlns: "jabber:client" }); if (type) { if (status) { dom.c("show").t(type); dom.up().c("status").t(status) } else { dom.c("show").t(type) } } this.sendCommand(dom.tree()) }; connection.prototype.getPresence = function () { var dom = $pres({ xmlns: "jabber:client" }); var conn = this; this.sendCommand(dom.tree()) }; connection.prototype.ping = function (options) { var options = options || {}; var jid = _getJid(options, this); var dom = $iq({ from: this.context.jid || "", to: jid, type: "get" }).c("ping", { xmlns: "urn:xmpp:ping" }); var suc = options.success || _utils.emptyfn; var error = options.error || this.onError; var failFn = function (ele) { error({ type: _code.WEBIM_CONNCTION_PING_ERROR, data: ele }) }; if (this.isOpened()) { this.context.stropheConn.sendIQ(dom.tree(), suc, failFn) } else { error({ type: _code.WEBIM_CONNCTION_DISCONNECTED }) } return }; connection.prototype.isOpened = function () { return this.context.status == _code.STATUS_OPENED }; connection.prototype.isOpening = function () { var status = this.context.status; return status == _code.STATUS_DOLOGIN_USERGRID || status == _code.STATUS_DOLOGIN_IM }; connection.prototype.isClosing = function () { return this.context.status == _code.STATUS_CLOSING }; connection.prototype.isClosed = function () { return this.context.status == _code.STATUS_CLOSED }; connection.prototype.clear = function () { var key = this.context.appKey; if (this.errorType != _code.WEBIM_CONNCTION_DISCONNECTED) { if (this.logOut) { this.unSendMsgArr = []; this.offLineSendConnecting = false; this.context = { status: _code.STATUS_INIT, appKey: key } } } if (this.intervalId) { clearInterval(this.intervalId) } this.restIndex = 0; this.xmppIndex = 0; if (this.errorType == _code.WEBIM_CONNCTION_CLIENT_LOGOUT || this.errorType == -1) { var message = { data: { data: "logout" }, type: _code.WEBIM_CONNCTION_CLIENT_LOGOUT }; this.onError(message) } }; connection.prototype.getChatRooms = function (options) { if (!_utils.isCanSetRequestHeader) { conn.onError({ type: _code.WEBIM_CONNCTION_NOT_SUPPORT_CHATROOM_ERROR }); return } var conn = this, token = options.accessToken || this.context.accessToken; if (token) { var apiUrl = options.apiUrl; var appName = this.context.appName; var orgName = this.context.orgName; if (!appName || !orgName) { conn.onError({ type: _code.WEBIM_CONNCTION_AUTH_ERROR }); return } var suc = function (data, xhr) { typeof options.success === "function" && options.success(data) }; var error = function (res, xhr, msg) { if (res.error && res.error_description) { conn.onError({ type: _code.WEBIM_CONNCTION_LOAD_CHATROOM_ERROR, msg: res.error_description, data: res, xhr: xhr }) } }; var pageInfo = { pagenum: parseInt(options.pagenum) || 1, pagesize: parseInt(options.pagesize) || 20 }; var opts = { url: apiUrl + "/" + orgName + "/" + appName + "/chatrooms", dataType: "json", type: "GET", headers: { "Authorization": "Bearer " + token }, data: pageInfo, success: suc || _utils.emptyfn, error: error || _utils.emptyfn }; _utils.ajax(opts) } else { conn.onError({ type: _code.WEBIM_CONNCTION_TOKEN_NOT_ASSIGN_ERROR }) } }; connection.prototype.joinChatRoom = function (options) { var roomJid = this.context.appKey + "_" + options.roomId + "@conference." + this.domain; var room_nick = roomJid + "/" + this.context.userId; var suc = options.success || _utils.emptyfn; var err = options.error || _utils.emptyfn; var errorFn = function (ele) { err({ type: _code.WEBIM_CONNCTION_JOINCHATROOM_ERROR, data: ele }) }; var iq = $pres({ from: this.context.jid, to: room_nick }).c("x", { xmlns: Strophe.NS.MUC + "#user" }).c("item", { affiliation: "member", role: "participant" }).up().up().c("roomtype", { xmlns: "easemob:x:roomtype", type: "chatroom" }); this.context.stropheConn.sendIQ(iq.tree(), suc, errorFn) }; connection.prototype.quitChatRoom = function (options) { var roomJid = this.context.appKey + "_" + options.roomId + "@conference." + this.domain; var room_nick = roomJid + "/" + this.context.userId; var suc = options.success || _utils.emptyfn; var err = options.error || _utils.emptyfn; var errorFn = function (ele) { err({ type: _code.WEBIM_CONNCTION_QUITCHATROOM_ERROR, data: ele }) }; var iq = $pres({ from: this.context.jid, to: room_nick, type: "unavailable" }).c("x", { xmlns: Strophe.NS.MUC + "#user" }).c("item", { affiliation: "none", role: "none" }).up().up().c("roomtype", { xmlns: "easemob:x:roomtype", type: "chatroom" }); this.context.stropheConn.sendIQ(iq.tree(), suc, errorFn) }; connection.prototype._onReceiveInviteFromGroup = function (info) { info = eval("(" + info + ")"); var self = this; var options = { title: "Group invitation", msg: info.user + " invites you to join into group:" + info.group_id, agree: function agree () { WebIM.doQuery('{"type":"acceptInvitationFromGroup","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) { }, function (code, msg) { var message = { data: { data: "acceptInvitationFromGroup error:" + msg }, type: _code.WEBIM_CONNECTION_ACCEPT_INVITATION_FROM_GROUP }; self.onError(message) }) }, reject: function reject () { WebIM.doQuery('{"type":"declineInvitationFromGroup","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) { }, function (code, msg) { var message = { data: { data: "declineInvitationFromGroup error:" + msg }, type: _code.WEBIM_CONNECTION_DECLINE_INVITATION_FROM_GROUP }; self.onError(message) }) } }; this.onConfirmPop(options) }; connection.prototype._onReceiveInviteAcceptionFromGroup = function (info) { info = eval("(" + info + ")"); var options = { title: "Group invitation response", msg: info.user + " agreed to join into group:" + info.group_id, agree: function agree () { } }; this.onConfirmPop(options) }; connection.prototype._onReceiveInviteDeclineFromGroup = function (info) { info = eval("(" + info + ")"); var options = { title: "Group invitation response", msg: info.user + " rejected to join into group:" + info.group_id, agree: function agree () { } }; this.onConfirmPop(options) }; connection.prototype._onAutoAcceptInvitationFromGroup = function (info) { info = eval("(" + info + ")"); var options = { title: "Group invitation", msg: "You had joined into the group:" + info.group_name + " automatically.Inviter:" + info.user, agree: function agree () { } }; this.onConfirmPop(options) }; connection.prototype._onLeaveGroup = function (info) { info = eval("(" + info + ")"); var options = { title: "Group notification", msg: "You have been out of the group:" + info.group_id + ".Reason:" + info.msg, agree: function agree () { } }; this.onConfirmPop(options) }; connection.prototype._onReceiveJoinGroupApplication = function (info) { info = eval("(" + info + ")"); var self = this; var options = { title: "Group join application", msg: info.user + " applys to join into group:" + info.group_id, agree: function agree () { WebIM.doQuery('{"type":"acceptJoinGroupApplication","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) { }, function (code, msg) { var message = { data: { data: "acceptJoinGroupApplication error:" + msg }, type: _code.WEBIM_CONNECTION_ACCEPT_JOIN_GROUP }; self.onError(message) }) }, reject: function reject () { WebIM.doQuery('{"type":"declineJoinGroupApplication","id":"' + info.group_id + '","user":"' + info.user + '"}', function (response) { }, function (code, msg) { var message = { data: { data: "declineJoinGroupApplication error:" + msg }, type: _code.WEBIM_CONNECTION_DECLINE_JOIN_GROUP }; self.onError(message) }) } }; this.onConfirmPop(options) }; connection.prototype._onReceiveAcceptionFromGroup = function (info) { info = eval("(" + info + ")"); var options = { title: "Group notification", msg: "You had joined into the group:" + info.group_name + ".", agree: function agree () { } }; this.onConfirmPop(options) }; connection.prototype._onReceiveRejectionFromGroup = function () { info = eval("(" + info + ")"); var options = { title: "Group notification", msg: "You have been rejected to join into the group:" + info.group_name + ".", agree: function agree () { } }; this.onConfirmPop(options) }; connection.prototype._onUpdateMyGroupList = function (options) { this.onUpdateMyGroupList(options) }; connection.prototype._onUpdateMyRoster = function (options) { this.onUpdateMyRoster(options) }; connection.prototype.reconnect = function (v) { var that = this; v && that.xmppIndex++; setTimeout(function () { _login(that.context.restTokenData, that) }, (this.autoReconnectNumTotal == 0 ? 0 : this.autoReconnectInterval) * 1000); this.autoReconnectNumTotal++ }; connection.prototype.closed = function () { var message = { data: { data: "Closed error" }, type: _code.WEBIM_CONNECTION_CLOSED }; this.onError(message) }; function _parsePrivacy (iq) { var list = {}; var items = iq.getElementsByTagName("item"); if (items) { for (var i = 0;i < items.length;i++) { var item = items[i]; var jid = item.getAttribute("value"); var order = item.getAttribute("order"); var type = item.getAttribute("type"); if (!jid) { continue } var n = _parseNameFromJidFn(jid); list[n] = { type: type, order: order, jid: jid, name: n } } } return list } connection.prototype.getBlacklist = function (options) { options = (options || {}); var iq = $iq({ type: "get" }); var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var me = this; iq.c("query", { xmlns: "jabber:iq:privacy" }).c("list", { name: "special" }); this.context.stropheConn.sendIQ(iq.tree(), function (iq) { me.onBlacklistUpdate(_parsePrivacy(iq)); sucFn() }, function () { me.onBlacklistUpdate([]); errFn() }) }; connection.prototype.addToBlackList = function (options) { var iq = $iq({ type: "set" }); var blacklist = options.list || {}; var type = options.type || "jid"; var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var piece = iq.c("query", { xmlns: "jabber:iq:privacy" }).c("list", { name: "special" }); var keys = Object.keys(blacklist); var len = keys.length; var order = 2; for (var i = 0;i < len;i++) { var item = blacklist[keys[i]]; var type = item.type || "jid"; var jid = item.jid; piece = piece.c("item", { action: "deny", order: order++, type: type, value: jid }).c("message"); if (i !== len - 1) { piece = piece.up().up() } } this.context.stropheConn.sendIQ(piece.tree(), sucFn, errFn) }; connection.prototype.removeFromBlackList = function (options) { var iq = $iq({ type: "set" }); var blacklist = options.list || {}; var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var piece = iq.c("query", { xmlns: "jabber:iq:privacy" }).c("list", { name: "special" }); var keys = Object.keys(blacklist); var len = keys.length; for (var i = 0;i < len;i++) { var item = blacklist[keys[i]]; var type = item.type || "jid"; var jid = item.jid; var order = item.order; piece = piece.c("item", { action: "deny", order: order, type: type, value: jid }).c("message"); if (i !== len - 1) { piece = piece.up().up() } } this.context.stropheConn.sendIQ(piece.tree(), sucFn, errFn) }; connection.prototype._getGroupJid = function (to) { var appKey = this.context.appKey || ""; return appKey + "_" + to + "@conference." + this.domain }; connection.prototype.addToGroupBlackList = function (options) { var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var jid = _getJid(options, this); var affiliation = "admin"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "set", to: to }); iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }).c("item", { affiliation: "outcast", jid: jid }); this.context.stropheConn.sendIQ(iq.tree(), sucFn, errFn) }; function _parseGroupBlacklist (iq) { var list = {}; var items = iq.getElementsByTagName("item"); if (items) { for (var i = 0;i < items.length;i++) { var item = items[i]; var jid = item.getAttribute("jid"); var affiliation = item.getAttribute("affiliation"); var nick = item.getAttribute("nick"); if (!jid) { continue } var n = _parseNameFromJidFn(jid); list[n] = { jid: jid, affiliation: affiliation, nick: nick, name: n } } } return list } connection.prototype.getGroupBlacklist = function (options) { var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var affiliation = "admin"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "get", to: to }); iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }).c("item", { affiliation: "outcast", }); this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) { sucFn(_parseGroupBlacklist(msginfo)) }, function () { errFn() }) }; connection.prototype.removeGroupMemberFromBlacklist = function (options) { var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var jid = _getJid(options, this); var affiliation = "admin"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "set", to: to }); iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }).c("item", { affiliation: "none", jid: jid }); this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) { sucFn() }, function () { errFn() }) }; connection.prototype.changeGroupSubject = function (options) { var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var affiliation = "owner"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "set", to: to }); iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }).c("x", { type: "submit", xmlns: "jabber:x:data" }).c("field", { "var": "FORM_TYPE" }).c("value").t("http://jabber.org/protocol/muc#roomconfig").up().up().c("field", { "var": "muc#roomconfig_roomname" }).c("value").t(options.subject).up().up().c("field", { "var": "muc#roomconfig_roomdesc" }).c("value").t(options.description); this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) { sucFn() }, function () { errFn() }) }; connection.prototype.destroyGroup = function (options) { var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var affiliation = "owner"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "set", to: to }); iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }).c("destroy").c("reason").t(options.reason || ""); this.context.stropheConn.sendIQ(iq.tree(), function (msginfo) { sucFn() }, function () { errFn() }) }; connection.prototype.leaveGroupBySelf = function (options) { var self = this; var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var jid = _getJid(options, this); var affiliation = "admin"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "set", to: to }); iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }).c("item", { affiliation: "none", jid: jid }); this.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) { sucFn(msgInfo); var pres = $pres({ type: "unavailable", to: to + "/" + self.context.userId }); self.sendCommand(pres.tree()) }, function (errInfo) { errFn(errInfo) }) }; connection.prototype.leaveGroup = function (options) { var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var list = options.list || []; var affiliation = "admin"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "set", to: to }); var piece = iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }); var keys = Object.keys(list); var len = keys.length; for (var i = 0;i < len;i++) { var name = list[keys[i]]; var jid = _getJidByName(name, this); piece = piece.c("item", { affiliation: "none", jid: jid }).up().c("item", { role: "none", jid: jid, }).up() } this.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) { sucFn(msgInfo) }, function (errInfo) { errFn(errInfo) }) }; connection.prototype.addGroupMembers = function (options) { console.log(10101010); var sucFn = options.success || _utils.emptyfn; var errFn = options.error || _utils.emptyfn; var list = options.list || []; var affiliation = "admin"; var to = this._getGroupJid(options.roomId); var iq = $iq({ type: "set", to: to }); var piece = iq.c("query", { xmlns: "http://jabber.org/protocol/muc#" + affiliation }); var len = list.length; for (var i = 0;i < len;i++) { var name = list[i]; var jid = _getJidByName(name, this); piece = piece.c("item", { affiliation: "member", jid: jid }).up(); var dom = $msg({ to: to }).c("x", { xmlns: "http://jabber.org/protocol/muc#user" }).c("invite", { to: jid }).c("reason").t(options.reason || ""); this.sendCommand(dom.tree()) } this.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) { sucFn(msgInfo) }, function (errInfo) { errFn(errInfo) }) }; connection.prototype.acceptInviteFromGroup = function (options) { options.success = function () { }; this.addGroupMembers(options) }; connection.prototype.rejectInviteFromGroup = function (options) { }; connection.prototype.createGroupAsync = function (p) { var roomId = p.from; var me = this; var toRoom = this._getGroupJid(roomId); var to = toRoom + "/" + this.context.userId; var options = this.groupOption; var suc = p.success || _utils.emptyfn; var iq = $iq({ type: "get", to: toRoom }).c("query", { xmlns: "http://jabber.org/protocol/muc#owner" }); me.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) { if ("setAttribute" in msgInfo) { var x = msgInfo.getElementsByTagName("x")[0]; x.setAttribute("type", "submit") } else { Strophe.forEachChild(msgInfo, "x", function (field) { field.setAttribute("type", "submit") }) } Strophe.info("step 5 ----------"); Strophe.forEachChild(x, "field", function (field) { var fieldVar = field.getAttribute("var"); var valueDom = field.getElementsByTagName("value")[0]; Strophe.info(fieldVar); switch (fieldVar) { case "muc#roomconfig_maxusers": _setText(valueDom, options.optionsMaxUsers || 200); break; case "muc#roomconfig_roomname": _setText(valueDom, options.subject || ""); break; case "muc#roomconfig_roomdesc": _setText(valueDom, options.description || ""); break; case "muc#roomconfig_publicroom": _setText(valueDom, +options.optionsPublic); break; case "muc#roomconfig_membersonly": _setText(valueDom, +options.optionsMembersOnly); break; case "muc#roomconfig_moderatedroom": _setText(valueDom, +options.optionsModerate); break; case "muc#roomconfig_persistentroom": _setText(valueDom, 1); break; case "muc#roomconfig_allowinvites": _setText(valueDom, +options.optionsAllowInvites); break; case "muc#roomconfig_allowvisitornickchange": _setText(valueDom, 0); break; case "muc#roomconfig_allowvisitorstatus": _setText(valueDom, 0); break; case "allow_private_messages": _setText(valueDom, 0); break; case "allow_private_messages_from_visitors": _setText(valueDom, "nobody"); break; default: break } }); var iq = $iq({ to: toRoom, type: "set" }).c("query", { xmlns: "http://jabber.org/protocol/muc#owner" }).cnode(x); me.context.stropheConn.sendIQ(iq.tree(), function (msgInfo) { me.addGroupMembers({ list: options.members, roomId: roomId }); suc(options) }, function (errInfo) { }) }, function (errInfo) { }) }; connection.prototype.createGroup = function (options) { this.groupOption = options; var roomId = +new Date(); var toRoom = this._getGroupJid(roomId); var to = toRoom + "/" + this.context.userId; var pres = $pres({ to: to }).c("x", { xmlns: "http://jabber.org/protocol/muc" }).up().c("create", { xmlns: "http://jabber.org/protocol/muc" }).up(); this.sendCommand(pres.tree()) }; connection.prototype.createGroupNew = function (opt) { opt.data.owner = this.user; opt.data.invite_need_confirm = false; var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/chatgroups", dataType: "json", type: "POST", data: JSON.stringify(opt.data), headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = function (respData) { opt.success(respData); this.onCreateGroup(respData) }.bind(this); options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.blockGroup = function (opt) { var groupId = opt.groupId; groupId = "notification_ignore_" + groupId; var data = { entities: [] }; data.entities[0] = {}; data.entities[0][groupId] = true; var options = { type: "PUT", url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "users" + "/" + this.user, data: JSON.stringify(data), headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.joinGroup = function (opt) { var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + opt.groupId + "/" + "apply", type: "POST", dataType: "json", data: JSON.stringify({ message: "join group" }), headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.listGroups = function (opt) { var requestData = []; requestData["limit"] = opt.limit; requestData["cursor"] = opt.cursor; if (!requestData["cursor"]) { delete requestData["cursor"] } if (isNaN(opt.limit)) { throw 'The parameter "limit" should be a number'; return } var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/publicchatgroups", type: "GET", dataType: "json", data: requestData, headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.getGroupInfo = function (opt) { var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/chatgroups/" + opt.groupId, type: "GET", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.getGroup = function (opt) { var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "users" + "/" + this.user + "/" + "joined_chatgroups", dataType: "json", type: "GET", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.listGroupMember = function (opt) { if (isNaN(opt.pageNum) || opt.pageNum <= 0) { throw 'The parameter "pageNum" should be a positive number'; return } else { if (isNaN(opt.pageSize) || opt.pageSize <= 0) { throw 'The parameter "pageSize" should be a positive number'; return } else { if (opt.groupId === null && typeof opt.groupId === "undefined") { throw 'The parameter "groupId" should be added'; return } } } var requestData = [], groupId = opt.groupId; requestData["pagenum"] = opt.pageNum; requestData["pagesize"] = opt.pageSize; var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/chatgroups" + "/" + groupId + "/users", dataType: "json", type: "GET", data: requestData, headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.mute = function (opt) { var groupId = opt.groupId, requestData = { "usernames": [opt.username], "mute_duration": opt.muteDuration }, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "mute", dataType: "json", type: "POST", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" }, data: JSON.stringify(requestData) }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.removeMute = function (opt) { var groupId = opt.groupId, username = opt.username; var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "mute" + "/" + username, dataType: "json", type: "DELETE", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.getGroupAdmin = function (opt) { var groupId = opt.groupId; var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/chatgroups" + "/" + groupId + "/admin", dataType: "json", type: "GET", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.getMuted = function (opt) { var groupId = opt.groupId; var options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/chatgroups" + "/" + groupId + "/mute", dataType: "json", type: "GET", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.setAdmin = function (opt) { var groupId = opt.groupId, requestData = { newadmin: opt.username }, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "admin", type: "POST", dataType: "json", data: JSON.stringify(requestData), headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.removeAdmin = function (opt) { var groupId = opt.groupId, username = opt.username, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "admin" + "/" + username, type: "DELETE", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.agreeJoinGroup = function (opt) { var groupId = opt.groupId, requestData = { "applicant": opt.applicant, "verifyResult": true, "reason": "no clue" }, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "apply_verify", type: "POST", dataType: "json", data: JSON.stringify(requestData), headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.rejectJoinGroup = function (opt) { var groupId = opt.groupId, requestData = { "applicant": opt.applicant, "verifyResult": false, "reason": "no clue" }, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "apply_verify", type: "POST", dataType: "json", data: JSON.stringify(requestData), headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.groupBlockSingle = function (opt) { var groupId = opt.groupId, username = opt.username, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "blocks" + "/" + "users" + "/" + username, type: "POST", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.groupBlockMulti = function (opt) { var groupId = opt.groupId, usernames = opt.usernames, requestData = { usernames: usernames }, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "blocks" + "/" + "users", data: JSON.stringify(requestData), type: "POST", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.removeGroupBlockSingle = function (opt) { var groupId = opt.groupId, username = opt.username, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "blocks" + "/" + "users" + "/" + username, type: "DELETE", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.removeGroupBlockMulti = function (opt) { var groupId = opt.groupId, username = opt.username.join(","), options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "blocks" + "/" + "users" + "/" + username, type: "DELETE", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.dissolveGroup = function (opt) { var groupId = opt.groupId, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "?version=v3", type: "DELETE", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.getGroupBlacklistNew = function (opt) { var groupId = opt.groupId, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "blocks" + "/" + "users", type: "GET", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.quitGroup = function (opt) { var groupId = opt.groupId, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "quit", type: "DELETE", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.modifyGroup = function (opt) { var groupId = opt.groupId, requestData = { groupname: opt.groupName, description: opt.description }, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId, type: "PUT", data: JSON.stringify(requestData), dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.removeSingleGroupMember = function (opt) { var groupId = opt.groupId, username = opt.username, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "users" + "/" + username, type: "DELETE", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.removeMultiGroupMember = function (opt) { var groupId = opt.groupId, users = opt.users.join(","), options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "users" + "/" + users, type: "DELETE", dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; connection.prototype.inviteToGroup = function (opt) { var groupId = opt.groupId, users = opt.users, requestData = { usernames: users }, options = { url: this.apiUrl + "/" + this.orgName + "/" + this.appName + "/" + "chatgroups" + "/" + groupId + "/" + "invite", type: "POST", data: JSON.stringify(requestData), dataType: "json", headers: { "Authorization": "Bearer " + this.token, "Content-Type": "application/json" } }; options.success = opt.success || _utils.emptyfn; options.error = opt.error || _utils.emptyfn; WebIM.utils.ajax(options) }; function _setText (valueDom, v) { if ("textContent" in valueDom) { valueDom.textContent = v } else { if ("text" in valueDom) { valueDom.text = v } else { } } } var WebIM = window.WebIM || {}; WebIM.connection = connection; WebIM.utils = _utils; WebIM.statusCode = _code; WebIM.message = _msg.message; WebIM.doQuery = function (str, suc, fail) { if (typeof window.cefQuery === "undefined") { return } window.cefQuery({ request: str, persistent: false, onSuccess: suc, onFailure: fail }) }; WebIM.debug = function (bool) { logMessage = function (message) { bool && console.log(WebIM.utils.ts() + "[recv] ", message.data) }; Strophe.Connection.prototype.rawOutput = function (data) { bool && console.log("%c " + WebIM.utils.ts() + "[send] " + data, "background-color: #e2f7da") } }; module.exports = WebIM; if (false) { module.hot.accept() } }), (function (module, exports) { (function () { exports.code = { WEBIM_CONNCTION_USER_NOT_ASSIGN_ERROR: 0, WEBIM_CONNCTION_OPEN_ERROR: 1, WEBIM_CONNCTION_AUTH_ERROR: 2, WEBIM_CONNCTION_OPEN_USERGRID_ERROR: 3, WEBIM_CONNCTION_ATTACH_ERROR: 4, WEBIM_CONNCTION_ATTACH_USERGRID_ERROR: 5, WEBIM_CONNCTION_REOPEN_ERROR: 6, WEBIM_CONNCTION_SERVER_CLOSE_ERROR: 7, WEBIM_CONNCTION_SERVER_ERROR: 8, WEBIM_CONNCTION_IQ_ERROR: 9, WEBIM_CONNCTION_PING_ERROR: 10, WEBIM_CONNCTION_NOTIFYVERSION_ERROR: 11, WEBIM_CONNCTION_GETROSTER_ERROR: 12, WEBIM_CONNCTION_CROSSDOMAIN_ERROR: 13, WEBIM_CONNCTION_LISTENING_OUTOF_MAXRETRIES: 14, WEBIM_CONNCTION_RECEIVEMSG_CONTENTERROR: 15, WEBIM_CONNCTION_DISCONNECTED: 16, WEBIM_CONNCTION_AJAX_ERROR: 17, WEBIM_CONNCTION_JOINROOM_ERROR: 18, WEBIM_CONNCTION_GETROOM_ERROR: 19, WEBIM_CONNCTION_GETROOMINFO_ERROR: 20, WEBIM_CONNCTION_GETROOMMEMBER_ERROR: 21, WEBIM_CONNCTION_GETROOMOCCUPANTS_ERROR: 22, WEBIM_CONNCTION_LOAD_CHATROOM_ERROR: 23, WEBIM_CONNCTION_NOT_SUPPORT_CHATROOM_ERROR: 24, WEBIM_CONNCTION_JOINCHATROOM_ERROR: 25, WEBIM_CONNCTION_QUITCHATROOM_ERROR: 26, WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR: 27, WEBIM_CONNCTION_TOKEN_NOT_ASSIGN_ERROR: 28, WEBIM_CONNCTION_SESSIONID_NOT_ASSIGN_ERROR: 29, WEBIM_CONNCTION_RID_NOT_ASSIGN_ERROR: 30, WEBIM_CONNCTION_CALLBACK_INNER_ERROR: 31, WEBIM_CONNCTION_CLIENT_OFFLINE: 32, WEBIM_CONNCTION_CLIENT_LOGOUT: 33, WEBIM_CONNCTION_CLIENT_TOO_MUCH_ERROR: 34, WEBIM_CONNECTION_ACCEPT_INVITATION_FROM_GROUP: 35, WEBIM_CONNECTION_DECLINE_INVITATION_FROM_GROUP: 36, WEBIM_CONNECTION_ACCEPT_JOIN_GROUP: 37, WEBIM_CONNECTION_DECLINE_JOIN_GROUP: 38, WEBIM_CONNECTION_CLOSED: 39, WEBIM_UPLOADFILE_BROWSER_ERROR: 100, WEBIM_UPLOADFILE_ERROR: 101, WEBIM_UPLOADFILE_NO_LOGIN: 102, WEBIM_UPLOADFILE_NO_FILE: 103, WEBIM_DOWNLOADFILE_ERROR: 200, WEBIM_DOWNLOADFILE_NO_LOGIN: 201, WEBIM_DOWNLOADFILE_BROWSER_ERROR: 202, WEBIM_MESSAGE_REC_TEXT: 300, WEBIM_MESSAGE_REC_TEXT_ERROR: 301, WEBIM_MESSAGE_REC_EMOTION: 302, WEBIM_MESSAGE_REC_PHOTO: 303, WEBIM_MESSAGE_REC_AUDIO: 304, WEBIM_MESSAGE_REC_AUDIO_FILE: 305, WEBIM_MESSAGE_REC_VEDIO: 306, WEBIM_MESSAGE_REC_VEDIO_FILE: 307, WEBIM_MESSAGE_REC_FILE: 308, WEBIM_MESSAGE_SED_TEXT: 309, WEBIM_MESSAGE_SED_EMOTION: 310, WEBIM_MESSAGE_SED_PHOTO: 311, WEBIM_MESSAGE_SED_AUDIO: 312, WEBIM_MESSAGE_SED_AUDIO_FILE: 313, WEBIM_MESSAGE_SED_VEDIO: 314, WEBIM_MESSAGE_SED_VEDIO_FILE: 315, WEBIM_MESSAGE_SED_FILE: 316, WEBIM_MESSAGE_SED_ERROR: 317, STATUS_INIT: 400, STATUS_DOLOGIN_USERGRID: 401, STATUS_DOLOGIN_IM: 402, STATUS_OPENED: 403, STATUS_CLOSING: 404, STATUS_CLOSED: 405, STATUS_ERROR: 406 } }()) }), (function (module, exports, __webpack_require__) { (function () { var EMPTYFN = function () { }; var _code = __webpack_require__(2).code; var WEBIM_FILESIZE_LIMIT = 10485760; var _createStandardXHR = function () { try { return new window.XMLHttpRequest() } catch (e) { return false } }; var _createActiveXHR = function () { try { return new window.ActiveXObject("Microsoft.XMLHTTP") } catch (e) { return false } }; var _xmlrequest = function (crossDomain) { crossDomain = crossDomain || true; var temp = _createStandardXHR() || _createActiveXHR(); if ("withCredentials" in temp) { return temp } if (!crossDomain) { return temp } if (typeof window.XDomainRequest === "undefined") { return temp } var xhr = new XDomainRequest(); xhr.readyState = 0; xhr.status = 100; xhr.onreadystatechange = EMPTYFN; xhr.onload = function () { xhr.readyState = 4; xhr.status = 200; var xmlDoc = new ActiveXObject("Microsoft.XMLDOM"); xmlDoc.async = "false"; xmlDoc.loadXML(xhr.responseText); xhr.responseXML = xmlDoc; xhr.response = xhr.responseText; xhr.onreadystatechange() }; xhr.ontimeout = xhr.onerror = function () { xhr.readyState = 4; xhr.status = 500; xhr.onreadystatechange() }; return xhr }; var _hasFlash = (function () { if ("ActiveXObject" in window) { try { return new ActiveXObject("ShockwaveFlash.ShockwaveFlash") } catch (ex) { return 0 } } else { if (navigator.plugins && navigator.plugins.length > 0) { return navigator.plugins["Shockwave Flash"] } } return 0 }()); var _tmpUtilXHR = _xmlrequest(), _hasFormData = typeof FormData !== "undefined", _hasBlob = typeof Blob !== "undefined", _isCanSetRequestHeader = _tmpUtilXHR.setRequestHeader || false, _hasOverrideMimeType = _tmpUtilXHR.overrideMimeType || false, _isCanUploadFileAsync = _isCanSetRequestHeader && _hasFormData, _isCanUploadFile = _isCanUploadFileAsync || _hasFlash, _isCanDownLoadFile = _isCanSetRequestHeader && (_hasBlob || _hasOverrideMimeType); if (!Object.keys) { Object.keys = (function () { var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({ toString: null }).propertyIsEnumerable("toString"), dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], dontEnumsLength = dontEnums.length; return function (obj) { if (typeof obj !== "object" && (typeof obj !== "function" || obj === null)) { throw new TypeError("Object.keys called on non-object") } var result = [], prop, i; for (prop in obj) { if (hasOwnProperty.call(obj, prop)) { result.push(prop) } } if (hasDontEnumBug) { for (i = 0;i < dontEnumsLength;i++) { if (hasOwnProperty.call(obj, dontEnums[i])) { result.push(dontEnums[i]) } } } return result } }()) } var utils = { hasFormData: _hasFormData, hasBlob: _hasBlob, emptyfn: EMPTYFN, isCanSetRequestHeader: _isCanSetRequestHeader, hasOverrideMimeType: _hasOverrideMimeType, isCanUploadFileAsync: _isCanUploadFileAsync, isCanUploadFile: _isCanUploadFile, isCanDownLoadFile: _isCanDownLoadFile, isSupportWss: (function () { var notSupportList = [/MQQBrowser[\/]5([.]\d+)?\sTBS/]; if (!window.WebSocket) { return false } var ua = window.navigator.userAgent; for (var i = 0, l = notSupportList.length;i < l;i++) { if (notSupportList[i].test(ua)) { return false } } return true }()), getIEVersion: (function () { var ua = navigator.userAgent, matches, tridentMap = { "4": 8, "5": 9, "6": 10, "7": 11 }; matches = ua.match(/MSIE (\d+)/i); if (matches && matches[1]) { return +matches[1] } matches = ua.match(/Trident\/(\d+)/i); if (matches && matches[1]) { return tridentMap[matches[1]] || null } return null }()), stringify: function (json) { if (typeof JSON !== "undefined" && JSON.stringify) { return JSON.stringify(json) } else { var s = "", arr = []; var iterate = function (json) { var isArr = false; if (Object.prototype.toString.call(json) === "[object Array]") { arr.push("]", "["); isArr = true } else { if (Object.prototype.toString.call(json) === "[object Object]") { arr.push("}", "{") } } for (var o in json) { if (Object.prototype.toString.call(json[o]) === "[object Null]") { json[o] = "null" } else { if (Object.prototype.toString.call(json[o]) === "[object Undefined]") { json[o] = "undefined" } } if (json[o] && typeof json[o] === "object") { s += "," + (isArr ? "" : '"' + o + '":' + (isArr ? '"' : "")) + iterate(json[o]) + "" } else { s += ',"' + (isArr ? "" : o + '":"') + json[o] + '"' } } if (s != "") { s = s.slice(1) } return arr.pop() + s + arr.pop() }; return iterate(json) } }, login: function (options) { var options = options || {}; var suc = options.success || EMPTYFN; var err = options.error || EMPTYFN; var appKey = options.appKey || ""; var devInfos = appKey.split("#"); if (devInfos.length !== 2) { err({ type: _code.WEBIM_CONNCTION_APPKEY_NOT_ASSIGN_ERROR }); return false } var orgName = devInfos[0]; var appName = devInfos[1]; var https = https || options.https; var user = options.user || ""; var pwd = options.pwd || ""; var apiUrl = options.apiUrl; var loginJson = { grant_type: "password", username: user, password: pwd, timestamp: +new Date() }; var loginfo = utils.stringify(loginJson); var options = { url: apiUrl + "/" + orgName + "/" + appName + "/token", dataType: "json", data: loginfo, success: suc, error: err }; return utils.ajax(options) }, getFileUrl: function (fileInputId) { var uri = { url: "", filename: "", filetype: "", data: "" }; var fileObj = typeof fileInputId === "string" ? document.getElementById(fileInputId) : fileInputId; if (!utils.isCanUploadFileAsync || !fileObj) { return uri } try { if (window.URL.createObjectURL) { var fileItems = fileObj.files; if (fileItems.length > 0) { var u = fileItems.item(0); uri.data = u; uri.url = window.URL.createObjectURL(u); uri.filename = u.name || "" } } else { var u = document.getElementById(fileInputId).value; uri.url = u; var pos1 = u.lastIndexOf("/"); var pos2 = u.lastIndexOf("\\"); var pos = Math.max(pos1, pos2); if (pos < 0) { uri.filename = u } else { uri.filename = u.substring(pos + 1) } } var index = uri.filename.lastIndexOf("."); if (index != -1) { uri.filetype = uri.filename.substring(index + 1).toLowerCase() } return uri } catch (e) { throw e } }, getFileSize: function (file) { var fileSize = this.getFileLength(file); if (fileSize > 10000000) { return false } var kb = Math.round(fileSize / 1000); if (kb < 1000) { fileSize = kb + " KB" } else { if (kb >= 1000) { var mb = kb / 1000; if (mb < 1000) { fileSize = mb.toFixed(1) + " MB" } else { var gb = mb / 1000; fileSize = gb.toFixed(1) + " GB" } } } return fileSize }, getFileLength: function (file) { var fileLength = 0; if (file) { if (file.files) { if (file.files.length > 0) { fileLength = file.files[0].size } } else { if (file.select && "ActiveXObject" in window) { file.select(); var fileobject = new ActiveXObject("Scripting.FileSystemObject"); var file = fileobject.GetFile(file.value); fileLength = file.Size } } } return fileLength }, hasFlash: _hasFlash, trim: function (str) { str = typeof str === "string" ? str : ""; return str.trim ? str.trim() : str.replace(/^\s|\s$/g, "") }, parseEmoji: function (msg) { if (typeof WebIM.Emoji === "undefined" || typeof WebIM.Emoji.map === "undefined") { return msg } else { var emoji = WebIM.Emoji, reg = null; for (var face in emoji.map) { if (emoji.map.hasOwnProperty(face)) { while (msg.indexOf(face) > -1) { msg = msg.replace(face, '<img class="emoji" src="' + emoji.path + emoji.map[face] + '" />') } } } return msg } }, parseLink: function (msg) { var reg = /(https?\:\/\/|www\.)([a-zA-Z0-9-]+(\.[a-zA-Z0-9]+)+)(\:[0-9]{2,4})?\/?((\.[:_0-9a-zA-Z-]+)|[:_0-9a-zA-Z-]*\/?)*\??[:_#@*&%0-9a-zA-Z-/=]*/gm; msg = msg.replace(reg, function (v) { var prefix = /^https?/gm.test(v); return "<a href='" + (prefix ? v : "//" + v) + "' target='_blank'>" + v + "</a>" }); return msg }, parseJSON: function (data) { if (window.JSON && window.JSON.parse) { return window.JSON.parse(data + "") } var requireNonComma, depth = null, str = utils.trim(data + ""); return str && !utils.trim(str.replace(/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g, function (token, comma, open, close) { if (requireNonComma && comma) { depth = 0 } if (depth === 0) { return token } requireNonComma = open || comma; depth += !close - !open; return "" })) ? (Function("return " + str))() : (Function("Invalid JSON: " + data))() }, parseUploadResponse: function (response) { return response.indexOf("callback") > -1 ? response.slice(9, -1) : response }, parseDownloadResponse: function (response) { return ((response && response.type && response.type === "application/json") || 0 > Object.prototype.toString.call(response).indexOf("Blob")) ? this.url + "?token=" : window.URL.createObjectURL(response) }, uploadFile: function (options) { var options = options || {}; options.onFileUploadProgress = options.onFileUploadProgress || EMPTYFN; options.onFileUploadComplete = options.onFileUploadComplete || EMPTYFN; options.onFileUploadError = options.onFileUploadError || EMPTYFN; options.onFileUploadCanceled = options.onFileUploadCanceled || EMPTYFN; var acc = options.accessToken || this.context.accessToken; if (!acc) { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_NO_LOGIN, id: options.id }); return } var orgName, appName, devInfos; var appKey = options.appKey || this.context.appKey || ""; if (appKey) { devInfos = appKey.split("#"); orgName = devInfos[0]; appName = devInfos[1] } if (!orgName && !appName) { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_ERROR, id: options.id }); return } var apiUrl = options.apiUrl; var uploadUrl = apiUrl + "/" + orgName + "/" + appName + "/chatfiles"; if (!utils.isCanUploadFileAsync) { if (utils.hasFlash && typeof options.flashUpload === "function") { options.flashUpload && options.flashUpload(uploadUrl, options) } else { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_BROWSER_ERROR, id: options.id }) } return } var fileSize = options.file.data ? options.file.data.size : undefined; if (fileSize > WEBIM_FILESIZE_LIMIT) { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_ERROR, id: options.id }); return } else { if (fileSize <= 0) { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_ERROR, id: options.id }); return } } var xhr = utils.xmlrequest(); var onError = function (e) { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_ERROR, id: options.id, xhr: xhr }) }; if (xhr.upload) { xhr.upload.addEventListener("progress", options.onFileUploadProgress, false) } if (xhr.addEventListener) { xhr.addEventListener("abort", options.onFileUploadCanceled, false); xhr.addEventListener("load", function (e) { try { var json = utils.parseJSON(xhr.responseText); try { options.onFileUploadComplete(json) } catch (e) { options.onFileUploadError({ type: _code.WEBIM_CONNCTION_CALLBACK_INNER_ERROR, data: e }) } } catch (e) { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_ERROR, data: xhr.responseText, id: options.id, xhr: xhr }) } }, false); xhr.addEventListener("error", onError, false) } else { if (xhr.onreadystatechange) { xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (ajax.status === 200) { try { var json = utils.parseJSON(xhr.responseText); options.onFileUploadComplete(json) } catch (e) { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_ERROR, data: xhr.responseText, id: options.id, xhr: xhr }) } } else { options.onFileUploadError({ type: _code.WEBIM_UPLOADFILE_ERROR, data: xhr.responseText, id: options.id, xhr: xhr }) } } else { xhr.abort(); options.onFileUploadCanceled() } } } } xhr.open("POST", uploadUrl); xhr.setRequestHeader("restrict-access", "true"); xhr.setRequestHeader("Accept", "*/*"); xhr.setRequestHeader("Authorization", "Bearer " + acc); var formData = new FormData(); formData.append("file", options.file.data); window.XDomainRequest && (xhr.readyState = 2); xhr.send(formData) }, download: function (options) { options.onFileDownloadComplete = options.onFileDownloadComplete || EMPTYFN; options.onFileDownloadError = options.onFileDownloadError || EMPTYFN; var accessToken = options.accessToken || this.context.accessToken; if (!accessToken) { options.onFileDownloadError({ type: _code.WEBIM_DOWNLOADFILE_NO_LOGIN, id: options.id }); return } var onError = function (e) { options.onFileDownloadError({ type: _code.WEBIM_DOWNLOADFILE_ERROR, id: options.id, xhr: xhr }) }; if (!utils.isCanDownLoadFile) { options.onFileDownloadComplete(); return } var xhr = utils.xmlrequest(); if ("addEventListener" in xhr) { xhr.addEventListener("load", function (e) { options.onFileDownloadComplete(xhr.response, xhr) }, false); xhr.addEventListener("error", onError, false) } else { if ("onreadystatechange" in xhr) { xhr.onreadystatechange = function () { if (xhr.readyState === 4) { if (ajax.status === 200) { options.onFileDownloadComplete(xhr.response, xhr) } else { options.onFileDownloadError({ type: _code.WEBIM_DOWNLOADFILE_ERROR, id: options.id, xhr: xhr }) } } else { xhr.abort(); options.onFileDownloadError({ type: _code.WEBIM_DOWNLOADFILE_ERROR, id: options.id, xhr: xhr }) } } } } var method = options.method || "GET"; var resType = options.responseType || "blob"; var mimeType = options.mimeType || "text/plain; charset=x-user-defined"; xhr.open(method, options.url); if (typeof Blob !== "undefined") { xhr.responseType = resType } else { xhr.overrideMimeType(mimeType) } var innerHeaer = { "X-Requested-With": "XMLHttpRequest", "Accept": "application/octet-stream", "share-secret": options.secret, "Authorization": "Bearer " + accessToken }; var headers = options.headers || {}; for (var key in headers) { innerHeaer[key] = headers[key] } for (var key in innerHeaer) { if (innerHeaer[key]) { xhr.setRequestHeader(key, innerHeaer[key]) } } window.XDomainRequest && (xhr.readyState = 2); xhr.send(null) }, parseTextMessage: function (message, faces) { if (typeof message !== "string") { return } if (Object.prototype.toString.call(faces) !== "[object Object]") { return { isemoji: false, body: [{ type: "txt", data: message }] } } var receiveMsg = message; var emessage = []; var expr = /\[[^[\]]{2,3}\]/mg; var emoji = receiveMsg.match(expr); if (!emoji || emoji.length < 1) { return { isemoji: false, body: [{ type: "txt", data: message }] } } var isemoji = false; for (var i = 0;i < emoji.length;i++) { var tmsg = receiveMsg.substring(0, receiveMsg.indexOf(emoji[i])), existEmoji = WebIM.Emoji.map[emoji[i]]; if (tmsg) { emessage.push({ type: "txt", data: tmsg }) } if (!existEmoji) { emessage.push({ type: "txt", data: emoji[i] }); continue } var emojiStr = WebIM.Emoji.map ? WebIM.Emoji.path + existEmoji : null; if (emojiStr) { isemoji = true; emessage.push({ type: "emoji", data: emojiStr }) } else { emessage.push({ type: "txt", data: emoji[i] }) } var restMsgIndex = receiveMsg.indexOf(emoji[i]) + emoji[i].length; receiveMsg = receiveMsg.substring(restMsgIndex) } if (receiveMsg) { emessage.push({ type: "txt", data: receiveMsg }) } if (isemoji) { return { isemoji: isemoji, body: emessage } } return { isemoji: false, body: [{ type: "txt", data: message }] } }, parseUri: function () { var pattern = /([^\?|&])\w+=([^&]+)/g; var uri = {}; if (window.location.search) { var args = window.location.search.match(pattern); for (var i in args) { var str = args[i]; var eq = str.indexOf("="); var key = str.substr(0, eq); var value = str.substr(eq + 1); uri[key] = value } } return uri }, parseHrefHash: function () { var pattern = /([^\#|&])\w+=([^&]+)/g; var uri = {}; if (window.location.hash) { var args = window.location.hash.match(pattern); for (var i in args) { var str = args[i]; var eq = str.indexOf("="); var key = str.substr(0, eq); var value = str.substr(eq + 1); uri[key] = value } } return uri }, xmlrequest: _xmlrequest, getXmlFirstChild: function (data, tagName) { var children = data.getElementsByTagName(tagName); if (children.length == 0) { return null } else { return children[0] } }, ajax: function (options) { var dataType = options.dataType || "text"; var suc = options.success || EMPTYFN; var error = options.error || EMPTYFN; var xhr = utils.xmlrequest(); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { var status = xhr.status || 0; if (status === 200) { try { switch (dataType) { case "text": suc(xhr.responseText); return; case "json": var json = utils.parseJSON(xhr.responseText); suc(json, xhr); return; case "xml": if (xhr.responseXML && xhr.responseXML.documentElement) { suc(xhr.responseXML.documentElement, xhr) } else { error({ type: _code.WEBIM_CONNCTION_AJAX_ERROR, data: xhr.responseText }) } return }suc(xhr.response || xhr.responseText, xhr) } catch (e) { error({ type: _code.WEBIM_CONNCTION_AJAX_ERROR, data: e }) } return } else { error({ type: _code.WEBIM_CONNCTION_AJAX_ERROR, data: xhr.responseText }); return } } if (xhr.readyState === 0) { error({ type: _code.WEBIM_CONNCTION_AJAX_ERROR, data: xhr.responseText }) } }; if (options.responseType) { if (xhr.responseType) { xhr.responseType = options.responseType } } if (options.mimeType) { if (utils.hasOverrideMimeType) { xhr.overrideMimeType(options.mimeType) } } var type = options.type || "POST", data = options.data || null, tempData = ""; if (type.toLowerCase() === "get" && data) { for (var o in data) { if (data.hasOwnProperty(o)) { tempData += o + "=" + data[o] + "&" } } tempData = tempData ? tempData.slice(0, -1) : tempData; options.url += (options.url.indexOf("?") > 0 ? "&" : "?") + (tempData ? tempData + "&" : tempData) + "_v=" + new Date().getTime(); data = null; tempData = null } xhr.open(type, options.url, utils.isCanSetRequestHeader); if (utils.isCanSetRequestHeader) { var headers = options.headers || {}; for (var key in headers) { if (headers.hasOwnProperty(key)) { xhr.setRequestHeader(key, headers[key]) } } } window.XDomainRequest && (xhr.readyState = 2); xhr.send(data); return xhr }, ts: function () { var d = new Date(); var Hours = d.getHours(); var Minutes = d.getMinutes(); var Seconds = d.getSeconds(); var Milliseconds = d.getMilliseconds(); return (Hours < 10 ? "0" + Hours : Hours) + ":" + (Minutes < 10 ? "0" + Minutes : Minutes) + ":" + (Seconds < 10 ? "0" + Seconds : Seconds) + ":" + Milliseconds + " " }, getObjectKey: function (obj, val) { for (var key in obj) { if (obj[key] == val) { return key } } return "" }, sprintf: function () { var arg = arguments, str = arg[0] || "", i, len; for (i = 1, len = arg.length;i < len;i++) { str = str.replace(/%s/, arg[i]) } return str }, setCookie: function (name, value, days) { var cookie = name + "=" + encodeURIComponent(value); if (typeof days == "number") { cookie += "; max-age: " + (days * 60 * 60 * 24) } document.cookie = cookie }, getCookie: function () { var allCookie = {}; var all = document.cookie; if (all === "") { return allCookie } var list = all.split("; "); for (var i = 0;i < list.length;i++) { var cookie = list[i]; var p = cookie.indexOf("="); var name = cookie.substring(0, p); var value = cookie.substring(p + 1); value = decodeURIComponent(value); allCookie[name] = value } return allCookie } }; exports.utils = utils }()) }), (function (module, exports, __webpack_require__) { var CryptoJS = __webpack_require__(5); (function () { var _utils = __webpack_require__(3).utils; var Message = function (type, id) { if (!this instanceof Message) { return new Message(type) } this._msg = {}; if (typeof Message[type] === "function") { Message[type].prototype.setGroup = this.setGroup; this._msg = new Message[type](id) } return this._msg }; Message.prototype.setGroup = function (group) { this.body.group = group }; Message.read = function (id) { this.id = id; this.type = "read" }; Message.read.prototype.set = function (opt) { this.body = { ackId: opt.id, to: opt.to } }; Message.delivery = function (id) { this.id = id; this.type = "delivery" }; Message.delivery.prototype.set = function (opt) { this.body = { bodyId: opt.id, to: opt.to } }; Message.txt = function (id) { this.id = id; this.type = "txt"; this.body = {} }; Message.txt.prototype.set = function (opt) { this.value = opt.msg; this.body = { id: this.id, to: opt.to, msg: this.value, type: this.type, roomType: opt.roomType, ext: opt.ext || {}, success: opt.success, fail: opt.fail }; !opt.roomType && delete this.body.roomType }; Message.cmd = function (id) { this.id = id; this.type = "cmd"; this.body = {} }; Message.cmd.prototype.set = function (opt) { this.value = ""; this.body = { to: opt.to, action: opt.action, msg: this.value, type: this.type, roomType: opt.roomType, ext: opt.ext || {}, success: opt.success }; !opt.roomType && delete this.body.roomType }; Message.location = function (id) { this.id = id; this.type = "loc"; this.body = {} }; Message.location.prototype.set = function (opt) { this.body = { to: opt.to, type: this.type, roomType: opt.roomType, addr: opt.addr, lat: opt.lat, lng: opt.lng, ext: opt.ext || {} } }; Message.img = function (id) { this.id = id; this.type = "img"; this.body = {} }; Message.img.prototype.set = function (opt) { opt.file = opt.file || _utils.getFileUrl(opt.fileInputId); this.value = opt.file; this.body = { id: this.id, file: this.value, apiUrl: opt.apiUrl, to: opt.to, type: this.type, ext: opt.ext || {}, roomType: opt.roomType, onFileUploadError: opt.onFileUploadError, onFileUploadComplete: opt.onFileUploadComplete, success: opt.success, fail: opt.fail, flashUpload: opt.flashUpload, width: opt.width, height: opt.height, body: opt.body, uploadError: opt.uploadError, uploadComplete: opt.uploadComplete }; !opt.roomType && delete this.body.roomType }; Message.audio = function (id) { this.id = id; this.type = "audio"; this.body = {} }; Message.audio.prototype.set = function (opt) { opt.file = opt.file || _utils.getFileUrl(opt.fileInputId); this.value = opt.file; this.filename = opt.filename || this.value.filename; this.body = { id: this.id, file: this.value, filename: this.filename, apiUrl: opt.apiUrl, to: opt.to, type: this.type, ext: opt.ext || {}, length: opt.length || 0, roomType: opt.roomType, file_length: opt.file_length, onFileUploadError: opt.onFileUploadError, onFileUploadComplete: opt.onFileUploadComplete, success: opt.success, fail: opt.fail, flashUpload: opt.flashUpload, body: opt.body }; !opt.roomType && delete this.body.roomType }; Message.file = function (id) { this.id = id; this.type = "file"; this.body = {} }; Message.file.prototype.set = function (opt) { opt.file = opt.file || _utils.getFileUrl(opt.fileInputId); this.value = opt.file; this.filename = opt.filename || this.value.filename; this.body = { id: this.id, file: this.value, filename: this.filename, apiUrl: opt.apiUrl, to: opt.to, type: this.type, ext: opt.ext || {}, roomType: opt.roomType, onFileUploadError: opt.onFileUploadError, onFileUploadComplete: opt.onFileUploadComplete, success: opt.success, fail: opt.fail, flashUpload: opt.flashUpload, body: opt.body }; !opt.roomType && delete this.body.roomType }; Message.video = function (id) { }; Message.video.prototype.set = function (opt) { }; var _Message = function (message) { if (!this instanceof _Message) { return new _Message(message, conn) } this.msg = message }; _Message.prototype.send = function (conn) { var me = this; var _send = function (message) { message.ext = message.ext || {}; message.ext.weichat = message.ext.weichat || {}; message.ext.weichat.originType = message.ext.weichat.originType || "webim"; var dom; var json = { from: conn.context.userId || "", to: message.to, bodies: [message.body], ext: message.ext || {} }; var jsonstr = _utils.stringify(json); dom = $msg({ type: message.group || "chat", to: message.toJid, id: message.id, xmlns: "jabber:client" }).c("body").t(jsonstr); if (message.roomType) { dom.up().c("roomtype", { xmlns: "easemob:x:roomtype", type: "chatroom" }) } if (message.bodyId) { dom = $msg({ from: conn.context.jid || "", to: message.toJid, id: message.id, xmlns: "jabber:client" }).c("body").t(message.bodyId); var delivery = { xmlns: "urn:xmpp:receipts", id: message.bodyId }; dom.up().c("delivery", delivery) } if (message.ackId) { if (conn.context.jid.indexOf(message.toJid) >= 0) { return } dom = $msg({ from: conn.context.jid || "", to: message.toJid, id: message.id, xmlns: "jabber:client" }).c("body").t(message.ackId); var read = { xmlns: "urn:xmpp:receipts", id: message.ackId }; dom.up().c("acked", read) } setTimeout(function () { if (typeof _msgHash !== "undefined" && _msgHash[message.id]) { _msgHash[message.id].msg.fail instanceof Function && _msgHash[message.id].msg.fail(message.id) } }, 60000); conn.sendCommand(dom.tree(), message.id) }; if (me.msg.file) { if (me.msg.body && me.msg.body.url) { _send(me.msg); return } var _tmpComplete = me.msg.onFileUploadComplete; var _complete = function (data) { if (data.entities[0]["file-metadata"]) { var file_len = data.entities[0]["file-metadata"]["content-length"]; me.msg.filetype = data.entities[0]["file-metadata"]["content-type"]; if (file_len > 204800) { me.msg.thumbnail = true } } me.msg.body = { type: me.msg.type || "file", url: ((location.protocol != "https:" && conn.isHttpDNS) ? (conn.apiUrl + data.uri.substr(data.uri.indexOf("/", 9))) : data.uri) + "/" + data.entities[0]["uuid"], secret: data.entities[0]["share-secret"], filename: me.msg.file.filename || me.msg.filename, size: { width: me.msg.width || 0, height: me.msg.height || 0 }, length: me.msg.length || 0, file_length: me.msg.ext.file_length || 0, filetype: me.msg.filetype }; _send(me.msg); _tmpComplete instanceof Function && _tmpComplete(data, me.msg.id) }; me.msg.onFileUploadComplete = _complete; _utils.uploadFile.call(conn, me.msg) } else { me.msg.body = { type: me.msg.type === "chat" ? "txt" : me.msg.type, msg: me.msg.msg }; if (me.msg.type === "cmd") { me.msg.body.action = me.msg.action } else { if (me.msg.type === "loc") { me.msg.body.addr = me.msg.addr; me.msg.body.lat = me.msg.lat; me.msg.body.lng = me.msg.lng } } _send(me.msg) } }; exports._msg = _Message; exports.message = Message }()) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(7), __webpack_require__(8), __webpack_require__(9), __webpack_require__(10), __webpack_require__(11), __webpack_require__(12), __webpack_require__(13), __webpack_require__(14), __webpack_require__(15), __webpack_require__(16), __webpack_require__(17), __webpack_require__(18), __webpack_require__(19), __webpack_require__(20), __webpack_require__(21), __webpack_require__(22), __webpack_require__(23), __webpack_require__(24), __webpack_require__(25), __webpack_require__(26), __webpack_require__(27), __webpack_require__(28), __webpack_require__(29), __webpack_require__(30), __webpack_require__(31), __webpack_require__(32), __webpack_require__(33), __webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory) } else { root.CryptoJS = factory(root.CryptoJS) } } }(this, function (CryptoJS) { return CryptoJS })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory() } else { if (typeof define === "function" && define.amd) { define([], factory) } else { root.CryptoJS = factory() } } }(this, function () { var CryptoJS = CryptoJS || (function (Math, undefined) { var create = Object.create || (function () { function F () { } return function (obj) { var subtype; F.prototype = obj; subtype = new F(); F.prototype = null; return subtype } }()); var C = {}; var C_lib = C.lib = {}; var Base = C_lib.Base = (function () { return { extend: function (overrides) { var subtype = create(this); if (overrides) { subtype.mixIn(overrides) } if (!subtype.hasOwnProperty("init") || this.init === subtype.init) { subtype.init = function () { subtype.$super.init.apply(this, arguments) } } subtype.init.prototype = subtype; subtype.$super = this; return subtype }, create: function () { var instance = this.extend(); instance.init.apply(instance, arguments); return instance }, init: function () { }, mixIn: function (properties) { for (var propertyName in properties) { if (properties.hasOwnProperty(propertyName)) { this[propertyName] = properties[propertyName] } } if (properties.hasOwnProperty("toString")) { this.toString = properties.toString } }, clone: function () { return this.init.prototype.extend(this) } } }()); var WordArray = C_lib.WordArray = Base.extend({ init: function (words, sigBytes) { words = this.words = words || []; if (sigBytes != undefined) { this.sigBytes = sigBytes } else { this.sigBytes = words.length * 4 } }, toString: function (encoder) { return (encoder || Hex).stringify(this) }, concat: function (wordArray) { var thisWords = this.words; var thatWords = wordArray.words; var thisSigBytes = this.sigBytes; var thatSigBytes = wordArray.sigBytes; this.clamp(); if (thisSigBytes % 4) { for (var i = 0;i < thatSigBytes;i++) { var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 255; thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8) } } else { for (var i = 0;i < thatSigBytes;i += 4) { thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2] } } this.sigBytes += thatSigBytes; return this }, clamp: function () { var words = this.words; var sigBytes = this.sigBytes; words[sigBytes >>> 2] &= 4294967295 << (32 - (sigBytes % 4) * 8); words.length = Math.ceil(sigBytes / 4) }, clone: function () { var clone = Base.clone.call(this); clone.words = this.words.slice(0); return clone }, random: function (nBytes) { var words = []; var r = (function (m_w) { var m_w = m_w; var m_z = 987654321; var mask = 4294967295; return function () { m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask; m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask; var result = ((m_z << 16) + m_w) & mask; result /= 4294967296; result += 0.5; return result * (Math.random() > 0.5 ? 1 : -1) } }); for (var i = 0, rcache;i < nBytes;i += 4) { var _r = r((rcache || Math.random()) * 4294967296); rcache = _r() * 987654071; words.push((_r() * 4294967296) | 0) } return new WordArray.init(words, nBytes) } }); var C_enc = C.enc = {}; var Hex = C_enc.Hex = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var hexChars = []; for (var i = 0;i < sigBytes;i++) { var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 255; hexChars.push((bite >>> 4).toString(16)); hexChars.push((bite & 15).toString(16)) } return hexChars.join("") }, parse: function (hexStr) { var hexStrLength = hexStr.length; var words = []; for (var i = 0;i < hexStrLength;i += 2) { words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4) } return new WordArray.init(words, hexStrLength / 2) } }; var Latin1 = C_enc.Latin1 = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var latin1Chars = []; for (var i = 0;i < sigBytes;i++) { var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 255; latin1Chars.push(String.fromCharCode(bite)) } return latin1Chars.join("") }, parse: function (latin1Str) { var latin1StrLength = latin1Str.length; var words = []; for (var i = 0;i < latin1StrLength;i++) { words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << (24 - (i % 4) * 8) } return new WordArray.init(words, latin1StrLength) } }; var Utf8 = C_enc.Utf8 = { stringify: function (wordArray) { try { return decodeURIComponent(escape(Latin1.stringify(wordArray))) } catch (e) { throw new Error("Malformed UTF-8 data") } }, parse: function (utf8Str) { return Latin1.parse(unescape(encodeURIComponent(utf8Str))) } }; var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({ reset: function () { this._data = new WordArray.init(); this._nDataBytes = 0 }, _append: function (data) { if (typeof data == "string") { data = Utf8.parse(data) } this._data.concat(data); this._nDataBytes += data.sigBytes }, _process: function (doFlush) { var data = this._data; var dataWords = data.words; var dataSigBytes = data.sigBytes; var blockSize = this.blockSize; var blockSizeBytes = blockSize * 4; var nBlocksReady = dataSigBytes / blockSizeBytes; if (doFlush) { nBlocksReady = Math.ceil(nBlocksReady) } else { nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0) } var nWordsReady = nBlocksReady * blockSize; var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); if (nWordsReady) { for (var offset = 0;offset < nWordsReady;offset += blockSize) { this._doProcessBlock(dataWords, offset) } var processedWords = dataWords.splice(0, nWordsReady); data.sigBytes -= nBytesReady } return new WordArray.init(processedWords, nBytesReady) }, clone: function () { var clone = Base.clone.call(this); clone._data = this._data.clone(); return clone }, _minBufferSize: 0 }); var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({ cfg: Base.extend(), init: function (cfg) { this.cfg = this.cfg.extend(cfg); this.reset() }, reset: function () { BufferedBlockAlgorithm.reset.call(this); this._doReset() }, update: function (messageUpdate) { this._append(messageUpdate); this._process(); return this }, finalize: function (messageUpdate) { if (messageUpdate) { this._append(messageUpdate) } var hash = this._doFinalize(); return hash }, blockSize: 512 / 32, _createHelper: function (hasher) { return function (message, cfg) { return new hasher.init(cfg).finalize(message) } }, _createHmacHelper: function (hasher) { return function (message, key) { return new C_algo.HMAC.init(hasher, key).finalize(message) } } }); var C_algo = C.algo = {}; return C }(Math)); return CryptoJS })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function (undefined) { var C = CryptoJS; var C_lib = C.lib; var Base = C_lib.Base; var X32WordArray = C_lib.WordArray; var C_x64 = C.x64 = {}; var X64Word = C_x64.Word = Base.extend({ init: function (high, low) { this.high = high; this.low = low } }); var X64WordArray = C_x64.WordArray = Base.extend({ init: function (words, sigBytes) { words = this.words = words || []; if (sigBytes != undefined) { this.sigBytes = sigBytes } else { this.sigBytes = words.length * 8 } }, toX32: function () { var x64Words = this.words; var x64WordsLength = x64Words.length; var x32Words = []; for (var i = 0;i < x64WordsLength;i++) { var x64Word = x64Words[i]; x32Words.push(x64Word.high); x32Words.push(x64Word.low) } return X32WordArray.create(x32Words, this.sigBytes) }, clone: function () { var clone = Base.clone.call(this); var words = clone.words = this.words.slice(0); var wordsLength = words.length; for (var i = 0;i < wordsLength;i++) { words[i] = words[i].clone() } return clone } }) }()); return CryptoJS })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { if (typeof ArrayBuffer != "function") { return } var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var superInit = WordArray.init; var subInit = WordArray.init = function (typedArray) { if (typedArray instanceof ArrayBuffer) { typedArray = new Uint8Array(typedArray) } if (typedArray instanceof Int8Array || (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) { typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength) } if (typedArray instanceof Uint8Array) { var typedArrayByteLength = typedArray.byteLength; var words = []; for (var i = 0;i < typedArrayByteLength;i++) { words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8) } superInit.call(this, words, typedArrayByteLength) } else { superInit.apply(this, arguments) } }; subInit.prototype = WordArray }()); return CryptoJS.lib.WordArray })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var C_enc = C.enc; var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var utf16Chars = []; for (var i = 0;i < sigBytes;i += 2) { var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 65535; utf16Chars.push(String.fromCharCode(codePoint)) } return utf16Chars.join("") }, parse: function (utf16Str) { var utf16StrLength = utf16Str.length; var words = []; for (var i = 0;i < utf16StrLength;i++) { words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16) } return WordArray.create(words, utf16StrLength * 2) } }; C_enc.Utf16LE = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var utf16Chars = []; for (var i = 0;i < sigBytes;i += 2) { var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 65535); utf16Chars.push(String.fromCharCode(codePoint)) } return utf16Chars.join("") }, parse: function (utf16Str) { var utf16StrLength = utf16Str.length; var words = []; for (var i = 0;i < utf16StrLength;i++) { words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16)) } return WordArray.create(words, utf16StrLength * 2) } }; function swapEndian (word) { return ((word << 8) & 4278255360) | ((word >>> 8) & 16711935) } }()); return CryptoJS.enc.Utf16 })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var C_enc = C.enc; var Base64 = C_enc.Base64 = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var map = this._map; wordArray.clamp(); var base64Chars = []; for (var i = 0;i < sigBytes;i += 3) { var byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 255; var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 255; var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 255; var triplet = (byte1 << 16) | (byte2 << 8) | byte3; for (var j = 0;(j < 4) && (i + j * 0.75 < sigBytes);j++) { base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 63)) } } var paddingChar = map.charAt(64); if (paddingChar) { while (base64Chars.length % 4) { base64Chars.push(paddingChar) } } return base64Chars.join("") }, parse: function (base64Str) { var base64StrLength = base64Str.length; var map = this._map; var reverseMap = this._reverseMap; if (!reverseMap) { reverseMap = this._reverseMap = []; for (var j = 0;j < map.length;j++) { reverseMap[map.charCodeAt(j)] = j } } var paddingChar = map.charAt(64); if (paddingChar) { var paddingIndex = base64Str.indexOf(paddingChar); if (paddingIndex !== -1) { base64StrLength = paddingIndex } } return parseLoop(base64Str, base64StrLength, reverseMap) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" }; function parseLoop (base64Str, base64StrLength, reverseMap) { var words = []; var nBytes = 0; for (var i = 0;i < base64StrLength;i++) { if (i % 4) { var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2); var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2); words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8); nBytes++ } } return WordArray.create(words, nBytes) } }()); return CryptoJS.enc.Base64 })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function (Math) { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var Hasher = C_lib.Hasher; var C_algo = C.algo; var T = []; (function () { for (var i = 0;i < 64;i++) { T[i] = (Math.abs(Math.sin(i + 1)) * 4294967296) | 0 } }()); var MD5 = C_algo.MD5 = Hasher.extend({ _doReset: function () { this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function (M, offset) { for (var i = 0;i < 16;i++) { var offset_i = offset + i; var M_offset_i = M[offset_i]; M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 16711935) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 4278255360)) } var H = this._hash.words; var M_offset_0 = M[offset + 0]; var M_offset_1 = M[offset + 1]; var M_offset_2 = M[offset + 2]; var M_offset_3 = M[offset + 3]; var M_offset_4 = M[offset + 4]; var M_offset_5 = M[offset + 5]; var M_offset_6 = M[offset + 6]; var M_offset_7 = M[offset + 7]; var M_offset_8 = M[offset + 8]; var M_offset_9 = M[offset + 9]; var M_offset_10 = M[offset + 10]; var M_offset_11 = M[offset + 11]; var M_offset_12 = M[offset + 12]; var M_offset_13 = M[offset + 13]; var M_offset_14 = M[offset + 14]; var M_offset_15 = M[offset + 15]; var a = H[0]; var b = H[1]; var c = H[2]; var d = H[3]; a = FF(a, b, c, d, M_offset_0, 7, T[0]); d = FF(d, a, b, c, M_offset_1, 12, T[1]); c = FF(c, d, a, b, M_offset_2, 17, T[2]); b = FF(b, c, d, a, M_offset_3, 22, T[3]); a = FF(a, b, c, d, M_offset_4, 7, T[4]); d = FF(d, a, b, c, M_offset_5, 12, T[5]); c = FF(c, d, a, b, M_offset_6, 17, T[6]); b = FF(b, c, d, a, M_offset_7, 22, T[7]); a = FF(a, b, c, d, M_offset_8, 7, T[8]); d = FF(d, a, b, c, M_offset_9, 12, T[9]); c = FF(c, d, a, b, M_offset_10, 17, T[10]); b = FF(b, c, d, a, M_offset_11, 22, T[11]); a = FF(a, b, c, d, M_offset_12, 7, T[12]); d = FF(d, a, b, c, M_offset_13, 12, T[13]); c = FF(c, d, a, b, M_offset_14, 17, T[14]); b = FF(b, c, d, a, M_offset_15, 22, T[15]); a = GG(a, b, c, d, M_offset_1, 5, T[16]); d = GG(d, a, b, c, M_offset_6, 9, T[17]); c = GG(c, d, a, b, M_offset_11, 14, T[18]); b = GG(b, c, d, a, M_offset_0, 20, T[19]); a = GG(a, b, c, d, M_offset_5, 5, T[20]); d = GG(d, a, b, c, M_offset_10, 9, T[21]); c = GG(c, d, a, b, M_offset_15, 14, T[22]); b = GG(b, c, d, a, M_offset_4, 20, T[23]); a = GG(a, b, c, d, M_offset_9, 5, T[24]); d = GG(d, a, b, c, M_offset_14, 9, T[25]); c = GG(c, d, a, b, M_offset_3, 14, T[26]); b = GG(b, c, d, a, M_offset_8, 20, T[27]); a = GG(a, b, c, d, M_offset_13, 5, T[28]); d = GG(d, a, b, c, M_offset_2, 9, T[29]); c = GG(c, d, a, b, M_offset_7, 14, T[30]); b = GG(b, c, d, a, M_offset_12, 20, T[31]); a = HH(a, b, c, d, M_offset_5, 4, T[32]); d = HH(d, a, b, c, M_offset_8, 11, T[33]); c = HH(c, d, a, b, M_offset_11, 16, T[34]); b = HH(b, c, d, a, M_offset_14, 23, T[35]); a = HH(a, b, c, d, M_offset_1, 4, T[36]); d = HH(d, a, b, c, M_offset_4, 11, T[37]); c = HH(c, d, a, b, M_offset_7, 16, T[38]); b = HH(b, c, d, a, M_offset_10, 23, T[39]); a = HH(a, b, c, d, M_offset_13, 4, T[40]); d = HH(d, a, b, c, M_offset_0, 11, T[41]); c = HH(c, d, a, b, M_offset_3, 16, T[42]); b = HH(b, c, d, a, M_offset_6, 23, T[43]); a = HH(a, b, c, d, M_offset_9, 4, T[44]); d = HH(d, a, b, c, M_offset_12, 11, T[45]); c = HH(c, d, a, b, M_offset_15, 16, T[46]); b = HH(b, c, d, a, M_offset_2, 23, T[47]); a = II(a, b, c, d, M_offset_0, 6, T[48]); d = II(d, a, b, c, M_offset_7, 10, T[49]); c = II(c, d, a, b, M_offset_14, 15, T[50]); b = II(b, c, d, a, M_offset_5, 21, T[51]); a = II(a, b, c, d, M_offset_12, 6, T[52]); d = II(d, a, b, c, M_offset_3, 10, T[53]); c = II(c, d, a, b, M_offset_10, 15, T[54]); b = II(b, c, d, a, M_offset_1, 21, T[55]); a = II(a, b, c, d, M_offset_8, 6, T[56]); d = II(d, a, b, c, M_offset_15, 10, T[57]); c = II(c, d, a, b, M_offset_6, 15, T[58]); b = II(b, c, d, a, M_offset_13, 21, T[59]); a = II(a, b, c, d, M_offset_4, 6, T[60]); d = II(d, a, b, c, M_offset_11, 10, T[61]); c = II(c, d, a, b, M_offset_2, 15, T[62]); b = II(b, c, d, a, M_offset_9, 21, T[63]); H[0] = (H[0] + a) | 0; H[1] = (H[1] + b) | 0; H[2] = (H[2] + c) | 0; H[3] = (H[3] + d) | 0 }, _doFinalize: function () { var data = this._data; var dataWords = data.words; var nBitsTotal = this._nDataBytes * 8; var nBitsLeft = data.sigBytes * 8; dataWords[nBitsLeft >>> 5] |= 128 << (24 - nBitsLeft % 32); var nBitsTotalH = Math.floor(nBitsTotal / 4294967296); var nBitsTotalL = nBitsTotal; dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 16711935) | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 4278255360)); dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 16711935) | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 4278255360)); data.sigBytes = (dataWords.length + 1) * 4; this._process(); var hash = this._hash; var H = hash.words; for (var i = 0;i < 4;i++) { var H_i = H[i]; H[i] = (((H_i << 8) | (H_i >>> 24)) & 16711935) | (((H_i << 24) | (H_i >>> 8)) & 4278255360) } return hash }, clone: function () { var clone = Hasher.clone.call(this); clone._hash = this._hash.clone(); return clone } }); function FF (a, b, c, d, x, s, t) { var n = a + ((b & c) | (~b & d)) + x + t; return ((n << s) | (n >>> (32 - s))) + b } function GG (a, b, c, d, x, s, t) { var n = a + ((b & d) | (c & ~d)) + x + t; return ((n << s) | (n >>> (32 - s))) + b } function HH (a, b, c, d, x, s, t) { var n = a + (b ^ c ^ d) + x + t; return ((n << s) | (n >>> (32 - s))) + b } function II (a, b, c, d, x, s, t) { var n = a + (c ^ (b | ~d)) + x + t; return ((n << s) | (n >>> (32 - s))) + b } C.MD5 = Hasher._createHelper(MD5); C.HmacMD5 = Hasher._createHmacHelper(MD5) }(Math)); return CryptoJS.MD5 })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var Hasher = C_lib.Hasher; var C_algo = C.algo; var W = []; var SHA1 = C_algo.SHA1 = Hasher.extend({ _doReset: function () { this._hash = new WordArray.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (M, offset) { var H = this._hash.words; var a = H[0]; var b = H[1]; var c = H[2]; var d = H[3]; var e = H[4]; for (var i = 0;i < 80;i++) { if (i < 16) { W[i] = M[offset + i] | 0 } else { var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]; W[i] = (n << 1) | (n >>> 31) } var t = ((a << 5) | (a >>> 27)) + e + W[i]; if (i < 20) { t += ((b & c) | (~b & d)) + 1518500249 } else { if (i < 40) { t += (b ^ c ^ d) + 1859775393 } else { if (i < 60) { t += ((b & c) | (b & d) | (c & d)) - 1894007588 } else { t += (b ^ c ^ d) - 899497514 } } } e = d; d = c; c = (b << 30) | (b >>> 2); b = a; a = t } H[0] = (H[0] + a) | 0; H[1] = (H[1] + b) | 0; H[2] = (H[2] + c) | 0; H[3] = (H[3] + d) | 0; H[4] = (H[4] + e) | 0 }, _doFinalize: function () { var data = this._data; var dataWords = data.words; var nBitsTotal = this._nDataBytes * 8; var nBitsLeft = data.sigBytes * 8; dataWords[nBitsLeft >>> 5] |= 128 << (24 - nBitsLeft % 32); dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 4294967296); dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal; data.sigBytes = dataWords.length * 4; this._process(); return this._hash }, clone: function () { var clone = Hasher.clone.call(this); clone._hash = this._hash.clone(); return clone } }); C.SHA1 = Hasher._createHelper(SHA1); C.HmacSHA1 = Hasher._createHmacHelper(SHA1) }()); return CryptoJS.SHA1 })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function (Math) { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var Hasher = C_lib.Hasher; var C_algo = C.algo; var H = []; var K = []; (function () { function isPrime (n) { var sqrtN = Math.sqrt(n); for (var factor = 2;factor <= sqrtN;factor++) { if (!(n % factor)) { return false } } return true } function getFractionalBits (n) { return ((n - (n | 0)) * 4294967296) | 0 } var n = 2; var nPrime = 0; while (nPrime < 64) { if (isPrime(n)) { if (nPrime < 8) { H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2)) } K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3)); nPrime++ } n++ } }()); var W = []; var SHA256 = C_algo.SHA256 = Hasher.extend({ _doReset: function () { this._hash = new WordArray.init(H.slice(0)) }, _doProcessBlock: function (M, offset) { var H = this._hash.words; var a = H[0]; var b = H[1]; var c = H[2]; var d = H[3]; var e = H[4]; var f = H[5]; var g = H[6]; var h = H[7]; for (var i = 0;i < 64;i++) { if (i < 16) { W[i] = M[offset + i] | 0 } else { var gamma0x = W[i - 15]; var gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^ ((gamma0x << 14) | (gamma0x >>> 18)) ^ (gamma0x >>> 3); var gamma1x = W[i - 2]; var gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^ ((gamma1x << 13) | (gamma1x >>> 19)) ^ (gamma1x >>> 10); W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16] } var ch = (e & f) ^ (~e & g); var maj = (a & b) ^ (a & c) ^ (b & c); var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22)); var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25)); var t1 = h + sigma1 + ch + K[i] + W[i]; var t2 = sigma0 + maj; h = g; g = f; f = e; e = (d + t1) | 0; d = c; c = b; b = a; a = (t1 + t2) | 0 } H[0] = (H[0] + a) | 0; H[1] = (H[1] + b) | 0; H[2] = (H[2] + c) | 0; H[3] = (H[3] + d) | 0; H[4] = (H[4] + e) | 0; H[5] = (H[5] + f) | 0; H[6] = (H[6] + g) | 0; H[7] = (H[7] + h) | 0 }, _doFinalize: function () { var data = this._data; var dataWords = data.words; var nBitsTotal = this._nDataBytes * 8; var nBitsLeft = data.sigBytes * 8; dataWords[nBitsLeft >>> 5] |= 128 << (24 - nBitsLeft % 32); dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 4294967296); dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal; data.sigBytes = dataWords.length * 4; this._process(); return this._hash }, clone: function () { var clone = Hasher.clone.call(this); clone._hash = this._hash.clone(); return clone } }); C.SHA256 = Hasher._createHelper(SHA256); C.HmacSHA256 = Hasher._createHmacHelper(SHA256) }(Math)); return CryptoJS.SHA256 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(13)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./sha256"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var C_algo = C.algo; var SHA256 = C_algo.SHA256; var SHA224 = C_algo.SHA224 = SHA256.extend({ _doReset: function () { this._hash = new WordArray.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]) }, _doFinalize: function () { var hash = SHA256._doFinalize.call(this); hash.sigBytes -= 4; return hash } }); C.SHA224 = SHA256._createHelper(SHA224); C.HmacSHA224 = SHA256._createHmacHelper(SHA224) }()); return CryptoJS.SHA224 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(7)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./x64-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var Hasher = C_lib.Hasher; var C_x64 = C.x64; var X64Word = C_x64.Word; var X64WordArray = C_x64.WordArray; var C_algo = C.algo; function X64Word_create () { return X64Word.create.apply(X64Word, arguments) } var K = [X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591)]; var W = []; (function () { for (var i = 0;i < 80;i++) { W[i] = X64Word_create() } }()); var SHA512 = C_algo.SHA512 = Hasher.extend({ _doReset: function () { this._hash = new X64WordArray.init([new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209)]) }, _doProcessBlock: function (M, offset) { var H = this._hash.words; var H0 = H[0]; var H1 = H[1]; var H2 = H[2]; var H3 = H[3]; var H4 = H[4]; var H5 = H[5]; var H6 = H[6]; var H7 = H[7]; var H0h = H0.high; var H0l = H0.low; var H1h = H1.high; var H1l = H1.low; var H2h = H2.high; var H2l = H2.low; var H3h = H3.high; var H3l = H3.low; var H4h = H4.high; var H4l = H4.low; var H5h = H5.high; var H5l = H5.low; var H6h = H6.high; var H6l = H6.low; var H7h = H7.high; var H7l = H7.low; var ah = H0h; var al = H0l; var bh = H1h; var bl = H1l; var ch = H2h; var cl = H2l; var dh = H3h; var dl = H3l; var eh = H4h; var el = H4l; var fh = H5h; var fl = H5l; var gh = H6h; var gl = H6l; var hh = H7h; var hl = H7l; for (var i = 0;i < 80;i++) { var Wi = W[i]; if (i < 16) { var Wih = Wi.high = M[offset + i * 2] | 0; var Wil = Wi.low = M[offset + i * 2 + 1] | 0 } else { var gamma0x = W[i - 15]; var gamma0xh = gamma0x.high; var gamma0xl = gamma0x.low; var gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7); var gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25)); var gamma1x = W[i - 2]; var gamma1xh = gamma1x.high; var gamma1xl = gamma1x.low; var gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6); var gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26)); var Wi7 = W[i - 7]; var Wi7h = Wi7.high; var Wi7l = Wi7.low; var Wi16 = W[i - 16]; var Wi16h = Wi16.high; var Wi16l = Wi16.low; var Wil = gamma0l + Wi7l; var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0); var Wil = Wil + gamma1l; var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0); var Wil = Wil + Wi16l; var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0); Wi.high = Wih; Wi.low = Wil } var chh = (eh & fh) ^ (~eh & gh); var chl = (el & fl) ^ (~el & gl); var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch); var majl = (al & bl) ^ (al & cl) ^ (bl & cl); var sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7)); var sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7)); var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9)); var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9)); var Ki = K[i]; var Kih = Ki.high; var Kil = Ki.low; var t1l = hl + sigma1l; var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0); var t1l = t1l + chl; var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0); var t1l = t1l + Kil; var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0); var t1l = t1l + Wil; var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0); var t2l = sigma0l + majl; var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0); hh = gh; hl = gl; gh = fh; gl = fl; fh = eh; fl = el; el = (dl + t1l) | 0; eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0; dh = ch; dl = cl; ch = bh; cl = bl; bh = ah; bl = al; al = (t1l + t2l) | 0; ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0 } H0l = H0.low = (H0l + al); H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0)); H1l = H1.low = (H1l + bl); H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0)); H2l = H2.low = (H2l + cl); H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0)); H3l = H3.low = (H3l + dl); H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0)); H4l = H4.low = (H4l + el); H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0)); H5l = H5.low = (H5l + fl); H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0)); H6l = H6.low = (H6l + gl); H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0)); H7l = H7.low = (H7l + hl); H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0)) }, _doFinalize: function () { var data = this._data; var dataWords = data.words; var nBitsTotal = this._nDataBytes * 8; var nBitsLeft = data.sigBytes * 8; dataWords[nBitsLeft >>> 5] |= 128 << (24 - nBitsLeft % 32); dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 4294967296); dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal; data.sigBytes = dataWords.length * 4; this._process(); var hash = this._hash.toX32(); return hash }, clone: function () { var clone = Hasher.clone.call(this); clone._hash = this._hash.clone(); return clone }, blockSize: 1024 / 32 }); C.SHA512 = Hasher._createHelper(SHA512); C.HmacSHA512 = Hasher._createHmacHelper(SHA512) }()); return CryptoJS.SHA512 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(7), __webpack_require__(15)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./x64-core", "./sha512"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_x64 = C.x64; var X64Word = C_x64.Word; var X64WordArray = C_x64.WordArray; var C_algo = C.algo; var SHA512 = C_algo.SHA512; var SHA384 = C_algo.SHA384 = SHA512.extend({ _doReset: function () { this._hash = new X64WordArray.init([new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428)]) }, _doFinalize: function () { var hash = SHA512._doFinalize.call(this); hash.sigBytes -= 16; return hash } }); C.SHA384 = SHA512._createHelper(SHA384); C.HmacSHA384 = SHA512._createHmacHelper(SHA384) }()); return CryptoJS.SHA384 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(7)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./x64-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function (Math) { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var Hasher = C_lib.Hasher; var C_x64 = C.x64; var X64Word = C_x64.Word; var C_algo = C.algo; var RHO_OFFSETS = []; var PI_INDEXES = []; var ROUND_CONSTANTS = []; (function () { var x = 1, y = 0; for (var t = 0;t < 24;t++) { RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64; var newX = y % 5; var newY = (2 * x + 3 * y) % 5; x = newX; y = newY } for (var x = 0;x < 5;x++) { for (var y = 0;y < 5;y++) { PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5 } } var LFSR = 1; for (var i = 0;i < 24;i++) { var roundConstantMsw = 0; var roundConstantLsw = 0; for (var j = 0;j < 7;j++) { if (LFSR & 1) { var bitPosition = (1 << j) - 1; if (bitPosition < 32) { roundConstantLsw ^= 1 << bitPosition } else { roundConstantMsw ^= 1 << (bitPosition - 32) } } if (LFSR & 128) { LFSR = (LFSR << 1) ^ 113 } else { LFSR <<= 1 } } ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw) } }()); var T = []; (function () { for (var i = 0;i < 25;i++) { T[i] = X64Word.create() } }()); var SHA3 = C_algo.SHA3 = Hasher.extend({ cfg: Hasher.cfg.extend({ outputLength: 512 }), _doReset: function () { var state = this._state = []; for (var i = 0;i < 25;i++) { state[i] = new X64Word.init() } this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32 }, _doProcessBlock: function (M, offset) { var state = this._state; var nBlockSizeLanes = this.blockSize / 2; for (var i = 0;i < nBlockSizeLanes;i++) { var M2i = M[offset + 2 * i]; var M2i1 = M[offset + 2 * i + 1]; M2i = ((((M2i << 8) | (M2i >>> 24)) & 16711935) | (((M2i << 24) | (M2i >>> 8)) & 4278255360)); M2i1 = ((((M2i1 << 8) | (M2i1 >>> 24)) & 16711935) | (((M2i1 << 24) | (M2i1 >>> 8)) & 4278255360)); var lane = state[i]; lane.high ^= M2i1; lane.low ^= M2i } for (var round = 0;round < 24;round++) { for (var x = 0;x < 5;x++) { var tMsw = 0, tLsw = 0; for (var y = 0;y < 5;y++) { var lane = state[x + 5 * y]; tMsw ^= lane.high; tLsw ^= lane.low } var Tx = T[x]; Tx.high = tMsw; Tx.low = tLsw } for (var x = 0;x < 5;x++) { var Tx4 = T[(x + 4) % 5]; var Tx1 = T[(x + 1) % 5]; var Tx1Msw = Tx1.high; var Tx1Lsw = Tx1.low; var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31)); var tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31)); for (var y = 0;y < 5;y++) { var lane = state[x + 5 * y]; lane.high ^= tMsw; lane.low ^= tLsw } } for (var laneIndex = 1;laneIndex < 25;laneIndex++) { var lane = state[laneIndex]; var laneMsw = lane.high; var laneLsw = lane.low; var rhoOffset = RHO_OFFSETS[laneIndex]; if (rhoOffset < 32) { var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset)); var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset)) } else { var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset)); var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset)) } var TPiLane = T[PI_INDEXES[laneIndex]]; TPiLane.high = tMsw; TPiLane.low = tLsw } var T0 = T[0]; var state0 = state[0]; T0.high = state0.high; T0.low = state0.low; for (var x = 0;x < 5;x++) { for (var y = 0;y < 5;y++) { var laneIndex = x + 5 * y; var lane = state[laneIndex]; var TLane = T[laneIndex]; var Tx1Lane = T[((x + 1) % 5) + 5 * y]; var Tx2Lane = T[((x + 2) % 5) + 5 * y]; lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high); lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low) } } var lane = state[0]; var roundConstant = ROUND_CONSTANTS[round]; lane.high ^= roundConstant.high; lane.low ^= roundConstant.low } }, _doFinalize: function () { var data = this._data; var dataWords = data.words; var nBitsTotal = this._nDataBytes * 8; var nBitsLeft = data.sigBytes * 8; var blockSizeBits = this.blockSize * 32; dataWords[nBitsLeft >>> 5] |= 1 << (24 - nBitsLeft % 32); dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 128; data.sigBytes = dataWords.length * 4; this._process(); var state = this._state; var outputLengthBytes = this.cfg.outputLength / 8; var outputLengthLanes = outputLengthBytes / 8; var hashWords = []; for (var i = 0;i < outputLengthLanes;i++) { var lane = state[i]; var laneMsw = lane.high; var laneLsw = lane.low; laneMsw = ((((laneMsw << 8) | (laneMsw >>> 24)) & 16711935) | (((laneMsw << 24) | (laneMsw >>> 8)) & 4278255360)); laneLsw = ((((laneLsw << 8) | (laneLsw >>> 24)) & 16711935) | (((laneLsw << 24) | (laneLsw >>> 8)) & 4278255360)); hashWords.push(laneLsw); hashWords.push(laneMsw) } return new WordArray.init(hashWords, outputLengthBytes) }, clone: function () { var clone = Hasher.clone.call(this); var state = clone._state = this._state.slice(0); for (var i = 0;i < 25;i++) { state[i] = state[i].clone() } return clone } }); C.SHA3 = Hasher._createHelper(SHA3); C.HmacSHA3 = Hasher._createHmacHelper(SHA3) }(Math)); return CryptoJS.SHA3 })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function (Math) { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var Hasher = C_lib.Hasher; var C_algo = C.algo; var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]); var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]); var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]); var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]); var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]); var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]); var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({ _doReset: function () { this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (M, offset) { for (var i = 0;i < 16;i++) { var offset_i = offset + i; var M_offset_i = M[offset_i]; M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 16711935) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 4278255360)) } var H = this._hash.words; var hl = _hl.words; var hr = _hr.words; var zl = _zl.words; var zr = _zr.words; var sl = _sl.words; var sr = _sr.words; var al, bl, cl, dl, el; var ar, br, cr, dr, er; ar = al = H[0]; br = bl = H[1]; cr = cl = H[2]; dr = dl = H[3]; er = el = H[4]; var t; for (var i = 0;i < 80;i += 1) { t = (al + M[offset + zl[i]]) | 0; if (i < 16) { t += f1(bl, cl, dl) + hl[0] } else { if (i < 32) { t += f2(bl, cl, dl) + hl[1] } else { if (i < 48) { t += f3(bl, cl, dl) + hl[2] } else { if (i < 64) { t += f4(bl, cl, dl) + hl[3] } else { t += f5(bl, cl, dl) + hl[4] } } } } t = t | 0; t = rotl(t, sl[i]); t = (t + el) | 0; al = el; el = dl; dl = rotl(cl, 10); cl = bl; bl = t; t = (ar + M[offset + zr[i]]) | 0; if (i < 16) { t += f5(br, cr, dr) + hr[0] } else { if (i < 32) { t += f4(br, cr, dr) + hr[1] } else { if (i < 48) { t += f3(br, cr, dr) + hr[2] } else { if (i < 64) { t += f2(br, cr, dr) + hr[3] } else { t += f1(br, cr, dr) + hr[4] } } } } t = t | 0; t = rotl(t, sr[i]); t = (t + er) | 0; ar = er; er = dr; dr = rotl(cr, 10); cr = br; br = t } t = (H[1] + cl + dr) | 0; H[1] = (H[2] + dl + er) | 0; H[2] = (H[3] + el + ar) | 0; H[3] = (H[4] + al + br) | 0; H[4] = (H[0] + bl + cr) | 0; H[0] = t }, _doFinalize: function () { var data = this._data; var dataWords = data.words; var nBitsTotal = this._nDataBytes * 8; var nBitsLeft = data.sigBytes * 8; dataWords[nBitsLeft >>> 5] |= 128 << (24 - nBitsLeft % 32); dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 16711935) | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 4278255360)); data.sigBytes = (dataWords.length + 1) * 4; this._process(); var hash = this._hash; var H = hash.words; for (var i = 0;i < 5;i++) { var H_i = H[i]; H[i] = (((H_i << 8) | (H_i >>> 24)) & 16711935) | (((H_i << 24) | (H_i >>> 8)) & 4278255360) } return hash }, clone: function () { var clone = Hasher.clone.call(this); clone._hash = this._hash.clone(); return clone } }); function f1 (x, y, z) { return ((x) ^ (y) ^ (z)) } function f2 (x, y, z) { return (((x) & (y)) | ((~x) & (z))) } function f3 (x, y, z) { return (((x) | (~(y))) ^ (z)) } function f4 (x, y, z) { return (((x) & (z)) | ((y) & (~(z)))) } function f5 (x, y, z) { return ((x) ^ ((y) | (~(z)))) } function rotl (x, n) { return (x << n) | (x >>> (32 - n)) } C.RIPEMD160 = Hasher._createHelper(RIPEMD160); C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160) }(Math)); return CryptoJS.RIPEMD160 })) }), (function (module, exports, __webpack_require__) { (function (root, factory) { if (true) { module.exports = exports = factory(__webpack_require__(6)) } else { if (typeof define === "function" && define.amd) { define(["./core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var Base = C_lib.Base; var C_enc = C.enc; var Utf8 = C_enc.Utf8; var C_algo = C.algo; var HMAC = C_algo.HMAC = Base.extend({ init: function (hasher, key) { hasher = this._hasher = new hasher.init(); if (typeof key == "string") { key = Utf8.parse(key) } var hasherBlockSize = hasher.blockSize; var hasherBlockSizeBytes = hasherBlockSize * 4; if (key.sigBytes > hasherBlockSizeBytes) { key = hasher.finalize(key) } key.clamp(); var oKey = this._oKey = key.clone(); var iKey = this._iKey = key.clone(); var oKeyWords = oKey.words; var iKeyWords = iKey.words; for (var i = 0;i < hasherBlockSize;i++) { oKeyWords[i] ^= 1549556828; iKeyWords[i] ^= 909522486 } oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes; this.reset() }, reset: function () { var hasher = this._hasher; hasher.reset(); hasher.update(this._iKey) }, update: function (messageUpdate) { this._hasher.update(messageUpdate); return this }, finalize: function (messageUpdate) { var hasher = this._hasher; var innerHash = hasher.finalize(messageUpdate); hasher.reset(); var hmac = hasher.finalize(this._oKey.clone().concat(innerHash)); return hmac } }) }()) })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(12), __webpack_require__(19)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./sha1", "./hmac"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var Base = C_lib.Base; var WordArray = C_lib.WordArray; var C_algo = C.algo; var SHA1 = C_algo.SHA1; var HMAC = C_algo.HMAC; var PBKDF2 = C_algo.PBKDF2 = Base.extend({ cfg: Base.extend({ keySize: 128 / 32, hasher: SHA1, iterations: 1 }), init: function (cfg) { this.cfg = this.cfg.extend(cfg) }, compute: function (password, salt) { var cfg = this.cfg; var hmac = HMAC.create(cfg.hasher, password); var derivedKey = WordArray.create(); var blockIndex = WordArray.create([1]); var derivedKeyWords = derivedKey.words; var blockIndexWords = blockIndex.words; var keySize = cfg.keySize; var iterations = cfg.iterations; while (derivedKeyWords.length < keySize) { var block = hmac.update(salt).finalize(blockIndex); hmac.reset(); var blockWords = block.words; var blockWordsLength = blockWords.length; var intermediate = block; for (var i = 1;i < iterations;i++) { intermediate = hmac.finalize(intermediate); hmac.reset(); var intermediateWords = intermediate.words; for (var j = 0;j < blockWordsLength;j++) { blockWords[j] ^= intermediateWords[j] } } derivedKey.concat(block); blockIndexWords[0]++ } derivedKey.sigBytes = keySize * 4; return derivedKey } }); C.PBKDF2 = function (password, salt, cfg) { return PBKDF2.create(cfg).compute(password, salt) } }()); return CryptoJS.PBKDF2 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(12), __webpack_require__(19)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./sha1", "./hmac"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var Base = C_lib.Base; var WordArray = C_lib.WordArray; var C_algo = C.algo; var MD5 = C_algo.MD5; var EvpKDF = C_algo.EvpKDF = Base.extend({ cfg: Base.extend({ keySize: 128 / 32, hasher: MD5, iterations: 1 }), init: function (cfg) { this.cfg = this.cfg.extend(cfg) }, compute: function (password, salt) { var cfg = this.cfg; var hasher = cfg.hasher.create(); var derivedKey = WordArray.create(); var derivedKeyWords = derivedKey.words; var keySize = cfg.keySize; var iterations = cfg.iterations; while (derivedKeyWords.length < keySize) { if (block) { hasher.update(block) } var block = hasher.update(password).finalize(salt); hasher.reset(); for (var i = 1;i < iterations;i++) { block = hasher.finalize(block); hasher.reset() } derivedKey.concat(block) } derivedKey.sigBytes = keySize * 4; return derivedKey } }); C.EvpKDF = function (password, salt, cfg) { return EvpKDF.create(cfg).compute(password, salt) } }()); return CryptoJS.EvpKDF })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(21)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./evpkdf"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.lib.Cipher || (function (undefined) { var C = CryptoJS; var C_lib = C.lib; var Base = C_lib.Base; var WordArray = C_lib.WordArray; var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm; var C_enc = C.enc; var Utf8 = C_enc.Utf8; var Base64 = C_enc.Base64; var C_algo = C.algo; var EvpKDF = C_algo.EvpKDF; var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({ cfg: Base.extend(), createEncryptor: function (key, cfg) { return this.create(this._ENC_XFORM_MODE, key, cfg) }, createDecryptor: function (key, cfg) { return this.create(this._DEC_XFORM_MODE, key, cfg) }, init: function (xformMode, key, cfg) { this.cfg = this.cfg.extend(cfg); this._xformMode = xformMode; this._key = key; this.reset() }, reset: function () { BufferedBlockAlgorithm.reset.call(this); this._doReset() }, process: function (dataUpdate) { this._append(dataUpdate); return this._process() }, finalize: function (dataUpdate) { if (dataUpdate) { this._append(dataUpdate) } var finalProcessedData = this._doFinalize(); return finalProcessedData }, keySize: 128 / 32, ivSize: 128 / 32, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: (function () { function selectCipherStrategy (key) { if (typeof key == "string") { return PasswordBasedCipher } else { return SerializableCipher } } return function (cipher) { return { encrypt: function (message, key, cfg) { return selectCipherStrategy(key).encrypt(cipher, message, key, cfg) }, decrypt: function (ciphertext, key, cfg) { return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg) } } } }()) }); var StreamCipher = C_lib.StreamCipher = Cipher.extend({ _doFinalize: function () { var finalProcessedBlocks = this._process(!!"flush"); return finalProcessedBlocks }, blockSize: 1 }); var C_mode = C.mode = {}; var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({ createEncryptor: function (cipher, iv) { return this.Encryptor.create(cipher, iv) }, createDecryptor: function (cipher, iv) { return this.Decryptor.create(cipher, iv) }, init: function (cipher, iv) { this._cipher = cipher; this._iv = iv } }); var CBC = C_mode.CBC = (function () { var CBC = BlockCipherMode.extend(); CBC.Encryptor = CBC.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; xorBlock.call(this, words, offset, blockSize); cipher.encryptBlock(words, offset); this._prevBlock = words.slice(offset, offset + blockSize) } }); CBC.Decryptor = CBC.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; var thisBlock = words.slice(offset, offset + blockSize); cipher.decryptBlock(words, offset); xorBlock.call(this, words, offset, blockSize); this._prevBlock = thisBlock } }); function xorBlock (words, offset, blockSize) { var iv = this._iv; if (iv) { var block = iv; this._iv = undefined } else { var block = this._prevBlock } for (var i = 0;i < blockSize;i++) { words[offset + i] ^= block[i] } } return CBC }()); var C_pad = C.pad = {}; var Pkcs7 = C_pad.Pkcs7 = { pad: function (data, blockSize) { var blockSizeBytes = blockSize * 4; var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes; var paddingWords = []; for (var i = 0;i < nPaddingBytes;i += 4) { paddingWords.push(paddingWord) } var padding = WordArray.create(paddingWords, nPaddingBytes); data.concat(padding) }, unpad: function (data) { var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 255; data.sigBytes -= nPaddingBytes } }; var BlockCipher = C_lib.BlockCipher = Cipher.extend({ cfg: Cipher.cfg.extend({ mode: CBC, padding: Pkcs7 }), reset: function () { Cipher.reset.call(this); var cfg = this.cfg; var iv = cfg.iv; var mode = cfg.mode; if (this._xformMode == this._ENC_XFORM_MODE) { var modeCreator = mode.createEncryptor } else { var modeCreator = mode.createDecryptor; this._minBufferSize = 1 } if (this._mode && this._mode.__creator == modeCreator) { this._mode.init(this, iv && iv.words) } else { this._mode = modeCreator.call(mode, this, iv && iv.words); this._mode.__creator = modeCreator } }, _doProcessBlock: function (words, offset) { this._mode.processBlock(words, offset) }, _doFinalize: function () { var padding = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { padding.pad(this._data, this.blockSize); var finalProcessedBlocks = this._process(!!"flush") } else { var finalProcessedBlocks = this._process(!!"flush"); padding.unpad(finalProcessedBlocks) } return finalProcessedBlocks }, blockSize: 128 / 32 }); var CipherParams = C_lib.CipherParams = Base.extend({ init: function (cipherParams) { this.mixIn(cipherParams) }, toString: function (formatter) { return (formatter || this.formatter).stringify(this) } }); var C_format = C.format = {}; var OpenSSLFormatter = C_format.OpenSSL = { stringify: function (cipherParams) { var ciphertext = cipherParams.ciphertext; var salt = cipherParams.salt; if (salt) { var wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext) } else { var wordArray = ciphertext } return wordArray.toString(Base64) }, parse: function (openSSLStr) { var ciphertext = Base64.parse(openSSLStr); var ciphertextWords = ciphertext.words; if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) { var salt = WordArray.create(ciphertextWords.slice(2, 4)); ciphertextWords.splice(0, 4); ciphertext.sigBytes -= 16 } return CipherParams.create({ ciphertext: ciphertext, salt: salt }) } }; var SerializableCipher = C_lib.SerializableCipher = Base.extend({ cfg: Base.extend({ format: OpenSSLFormatter }), encrypt: function (cipher, message, key, cfg) { cfg = this.cfg.extend(cfg); var encryptor = cipher.createEncryptor(key, cfg); var ciphertext = encryptor.finalize(message); var cipherCfg = encryptor.cfg; return CipherParams.create({ ciphertext: ciphertext, key: key, iv: cipherCfg.iv, algorithm: cipher, mode: cipherCfg.mode, padding: cipherCfg.padding, blockSize: cipher.blockSize, formatter: cfg.format }) }, decrypt: function (cipher, ciphertext, key, cfg) { cfg = this.cfg.extend(cfg); ciphertext = this._parse(ciphertext, cfg.format); var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext); return plaintext }, _parse: function (ciphertext, format) { if (typeof ciphertext == "string") { return format.parse(ciphertext, this) } else { return ciphertext } } }); var C_kdf = C.kdf = {}; var OpenSSLKdf = C_kdf.OpenSSL = { execute: function (password, keySize, ivSize, salt) { if (!salt) { salt = WordArray.random(64 / 8) } var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt); var iv = WordArray.create(key.words.slice(keySize), ivSize * 4); key.sigBytes = keySize * 4; return CipherParams.create({ key: key, iv: iv, salt: salt }) } }; var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({ cfg: SerializableCipher.cfg.extend({ kdf: OpenSSLKdf }), encrypt: function (cipher, message, password, cfg) { cfg = this.cfg.extend(cfg); var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); cfg.iv = derivedParams.iv; var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg); ciphertext.mixIn(derivedParams); return ciphertext }, decrypt: function (cipher, ciphertext, password, cfg) { cfg = this.cfg.extend(cfg); ciphertext = this._parse(ciphertext, cfg.format); var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt); cfg.iv = derivedParams.iv; var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg); return plaintext } }) }()) })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.mode.CFB = (function () { var CFB = CryptoJS.lib.BlockCipherMode.extend(); CFB.Encryptor = CFB.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); this._prevBlock = words.slice(offset, offset + blockSize) } }); CFB.Decryptor = CFB.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; var thisBlock = words.slice(offset, offset + blockSize); generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); this._prevBlock = thisBlock } }); function generateKeystreamAndEncrypt (words, offset, blockSize, cipher) { var iv = this._iv; if (iv) { var keystream = iv.slice(0); this._iv = undefined } else { var keystream = this._prevBlock } cipher.encryptBlock(keystream, 0); for (var i = 0;i < blockSize;i++) { words[offset + i] ^= keystream[i] } } return CFB }()); return CryptoJS.mode.CFB })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.mode.CTR = (function () { var CTR = CryptoJS.lib.BlockCipherMode.extend(); var Encryptor = CTR.Encryptor = CTR.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; var iv = this._iv; var counter = this._counter; if (iv) { counter = this._counter = iv.slice(0); this._iv = undefined } var keystream = counter.slice(0); cipher.encryptBlock(keystream, 0); counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0; for (var i = 0;i < blockSize;i++) { words[offset + i] ^= keystream[i] } } }); CTR.Decryptor = Encryptor; return CTR }()); return CryptoJS.mode.CTR })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.mode.CTRGladman = (function () { var CTRGladman = CryptoJS.lib.BlockCipherMode.extend(); function incWord (word) { if (((word >> 24) & 255) === 255) { var b1 = (word >> 16) & 255; var b2 = (word >> 8) & 255; var b3 = word & 255; if (b1 === 255) { b1 = 0; if (b2 === 255) { b2 = 0; if (b3 === 255) { b3 = 0 } else { ++b3 } } else { ++b2 } } else { ++b1 } word = 0; word += (b1 << 16); word += (b2 << 8); word += b3 } else { word += (1 << 24) } return word } function incCounter (counter) { if ((counter[0] = incWord(counter[0])) === 0) { counter[1] = incWord(counter[1]) } return counter } var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; var iv = this._iv; var counter = this._counter; if (iv) { counter = this._counter = iv.slice(0); this._iv = undefined } incCounter(counter); var keystream = counter.slice(0); cipher.encryptBlock(keystream, 0); for (var i = 0;i < blockSize;i++) { words[offset + i] ^= keystream[i] } } }); CTRGladman.Decryptor = Encryptor; return CTRGladman }()); return CryptoJS.mode.CTRGladman })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.mode.OFB = (function () { var OFB = CryptoJS.lib.BlockCipherMode.extend(); var Encryptor = OFB.Encryptor = OFB.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; var iv = this._iv; var keystream = this._keystream; if (iv) { keystream = this._keystream = iv.slice(0); this._iv = undefined } cipher.encryptBlock(keystream, 0); for (var i = 0;i < blockSize;i++) { words[offset + i] ^= keystream[i] } } }); OFB.Decryptor = Encryptor; return OFB }()); return CryptoJS.mode.OFB })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.mode.ECB = (function () { var ECB = CryptoJS.lib.BlockCipherMode.extend(); ECB.Encryptor = ECB.extend({ processBlock: function (words, offset) { this._cipher.encryptBlock(words, offset) } }); ECB.Decryptor = ECB.extend({ processBlock: function (words, offset) { this._cipher.decryptBlock(words, offset) } }); return ECB }()); return CryptoJS.mode.ECB })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.pad.AnsiX923 = { pad: function (data, blockSize) { var dataSigBytes = data.sigBytes; var blockSizeBytes = blockSize * 4; var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes; var lastBytePos = dataSigBytes + nPaddingBytes - 1; data.clamp(); data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8); data.sigBytes += nPaddingBytes }, unpad: function (data) { var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 255; data.sigBytes -= nPaddingBytes } }; return CryptoJS.pad.Ansix923 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.pad.Iso10126 = { pad: function (data, blockSize) { var blockSizeBytes = blockSize * 4; var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1)) }, unpad: function (data) { var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 255; data.sigBytes -= nPaddingBytes } }; return CryptoJS.pad.Iso10126 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.pad.Iso97971 = { pad: function (data, blockSize) { data.concat(CryptoJS.lib.WordArray.create([2147483648], 1)); CryptoJS.pad.ZeroPadding.pad(data, blockSize) }, unpad: function (data) { CryptoJS.pad.ZeroPadding.unpad(data); data.sigBytes-- } }; return CryptoJS.pad.Iso97971 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.pad.ZeroPadding = { pad: function (data, blockSize) { var blockSizeBytes = blockSize * 4; data.clamp(); data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes) }, unpad: function (data) { var dataWords = data.words; var i = data.sigBytes - 1; while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 255)) { i-- } data.sigBytes = i + 1 } }; return CryptoJS.pad.ZeroPadding })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { CryptoJS.pad.NoPadding = { pad: function () { }, unpad: function () { } }; return CryptoJS.pad.NoPadding })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function (undefined) { var C = CryptoJS; var C_lib = C.lib; var CipherParams = C_lib.CipherParams; var C_enc = C.enc; var Hex = C_enc.Hex; var C_format = C.format; var HexFormatter = C_format.Hex = { stringify: function (cipherParams) { return cipherParams.ciphertext.toString(Hex) }, parse: function (input) { var ciphertext = Hex.parse(input); return CipherParams.create({ ciphertext: ciphertext }) } } }()); return CryptoJS.format.Hex })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10), __webpack_require__(11), __webpack_require__(21), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var BlockCipher = C_lib.BlockCipher; var C_algo = C.algo; var SBOX = []; var INV_SBOX = []; var SUB_MIX_0 = []; var SUB_MIX_1 = []; var SUB_MIX_2 = []; var SUB_MIX_3 = []; var INV_SUB_MIX_0 = []; var INV_SUB_MIX_1 = []; var INV_SUB_MIX_2 = []; var INV_SUB_MIX_3 = []; (function () { var d = []; for (var i = 0;i < 256;i++) { if (i < 128) { d[i] = i << 1 } else { d[i] = (i << 1) ^ 283 } } var x = 0; var xi = 0; for (var i = 0;i < 256;i++) { var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4); sx = (sx >>> 8) ^ (sx & 255) ^ 99; SBOX[x] = sx; INV_SBOX[sx] = x; var x2 = d[x]; var x4 = d[x2]; var x8 = d[x4]; var t = (d[sx] * 257) ^ (sx * 16843008); SUB_MIX_0[x] = (t << 24) | (t >>> 8); SUB_MIX_1[x] = (t << 16) | (t >>> 16); SUB_MIX_2[x] = (t << 8) | (t >>> 24); SUB_MIX_3[x] = t; var t = (x8 * 16843009) ^ (x4 * 65537) ^ (x2 * 257) ^ (x * 16843008); INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8); INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16); INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24); INV_SUB_MIX_3[sx] = t; if (!x) { x = xi = 1 } else { x = x2 ^ d[d[d[x8 ^ x2]]]; xi ^= d[d[xi]] } } }()); var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]; var AES = C_algo.AES = BlockCipher.extend({ _doReset: function () { if (this._nRounds && this._keyPriorReset === this._key) { return } var key = this._keyPriorReset = this._key; var keyWords = key.words; var keySize = key.sigBytes / 4; var nRounds = this._nRounds = keySize + 6; var ksRows = (nRounds + 1) * 4; var keySchedule = this._keySchedule = []; for (var ksRow = 0;ksRow < ksRows;ksRow++) { if (ksRow < keySize) { keySchedule[ksRow] = keyWords[ksRow] } else { var t = keySchedule[ksRow - 1]; if (!(ksRow % keySize)) { t = (t << 8) | (t >>> 24); t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 255] << 16) | (SBOX[(t >>> 8) & 255] << 8) | SBOX[t & 255]; t ^= RCON[(ksRow / keySize) | 0] << 24 } else { if (keySize > 6 && ksRow % keySize == 4) { t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 255] << 16) | (SBOX[(t >>> 8) & 255] << 8) | SBOX[t & 255] } } keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t } } var invKeySchedule = this._invKeySchedule = []; for (var invKsRow = 0;invKsRow < ksRows;invKsRow++) { var ksRow = ksRows - invKsRow; if (invKsRow % 4) { var t = keySchedule[ksRow] } else { var t = keySchedule[ksRow - 4] } if (invKsRow < 4 || ksRow <= 4) { invKeySchedule[invKsRow] = t } else { invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 255]] ^ INV_SUB_MIX_2[SBOX[(t >>> 8) & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]] } } }, encryptBlock: function (M, offset) { this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) }, decryptBlock: function (M, offset) { var t = M[offset + 1]; M[offset + 1] = M[offset + 3]; M[offset + 3] = t; this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); var t = M[offset + 1]; M[offset + 1] = M[offset + 3]; M[offset + 3] = t }, _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) { var nRounds = this._nRounds; var s0 = M[offset] ^ keySchedule[0]; var s1 = M[offset + 1] ^ keySchedule[1]; var s2 = M[offset + 2] ^ keySchedule[2]; var s3 = M[offset + 3] ^ keySchedule[3]; var ksRow = 4; for (var round = 1;round < nRounds;round++) { var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 255] ^ SUB_MIX_2[(s2 >>> 8) & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow++]; var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 255] ^ SUB_MIX_2[(s3 >>> 8) & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow++]; var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 255] ^ SUB_MIX_2[(s0 >>> 8) & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow++]; var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 255] ^ SUB_MIX_2[(s1 >>> 8) & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow++]; s0 = t0; s1 = t1; s2 = t2; s3 = t3 } var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 255] << 16) | (SBOX[(s2 >>> 8) & 255] << 8) | SBOX[s3 & 255]) ^ keySchedule[ksRow++]; var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 255] << 16) | (SBOX[(s3 >>> 8) & 255] << 8) | SBOX[s0 & 255]) ^ keySchedule[ksRow++]; var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 255] << 16) | (SBOX[(s0 >>> 8) & 255] << 8) | SBOX[s1 & 255]) ^ keySchedule[ksRow++]; var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 255] << 16) | (SBOX[(s1 >>> 8) & 255] << 8) | SBOX[s2 & 255]) ^ keySchedule[ksRow++]; M[offset] = t0; M[offset + 1] = t1; M[offset + 2] = t2; M[offset + 3] = t3 }, keySize: 256 / 32 }); C.AES = BlockCipher._createHelper(AES) }()); return CryptoJS.AES })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10), __webpack_require__(11), __webpack_require__(21), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var BlockCipher = C_lib.BlockCipher; var C_algo = C.algo; var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]; var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]; var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]; var SBOX_P = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }]; var SBOX_MASK = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]; var DES = C_algo.DES = BlockCipher.extend({ _doReset: function () { var key = this._key; var keyWords = key.words; var keyBits = []; for (var i = 0;i < 56;i++) { var keyBitPos = PC1[i] - 1; keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1 } var subKeys = this._subKeys = []; for (var nSubKey = 0;nSubKey < 16;nSubKey++) { var subKey = subKeys[nSubKey] = []; var bitShift = BIT_SHIFTS[nSubKey]; for (var i = 0;i < 24;i++) { subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6); subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6) } subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31); for (var i = 1;i < 7;i++) { subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3) } subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27) } var invSubKeys = this._invSubKeys = []; for (var i = 0;i < 16;i++) { invSubKeys[i] = subKeys[15 - i] } }, encryptBlock: function (M, offset) { this._doCryptBlock(M, offset, this._subKeys) }, decryptBlock: function (M, offset) { this._doCryptBlock(M, offset, this._invSubKeys) }, _doCryptBlock: function (M, offset, subKeys) { this._lBlock = M[offset]; this._rBlock = M[offset + 1]; exchangeLR.call(this, 4, 252645135); exchangeLR.call(this, 16, 65535); exchangeRL.call(this, 2, 858993459); exchangeRL.call(this, 8, 16711935); exchangeLR.call(this, 1, 1431655765); for (var round = 0;round < 16;round++) { var subKey = subKeys[round]; var lBlock = this._lBlock; var rBlock = this._rBlock; var f = 0; for (var i = 0;i < 8;i++) { f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0] } this._lBlock = rBlock; this._rBlock = lBlock ^ f } var t = this._lBlock; this._lBlock = this._rBlock; this._rBlock = t; exchangeLR.call(this, 1, 1431655765); exchangeRL.call(this, 8, 16711935); exchangeRL.call(this, 2, 858993459); exchangeLR.call(this, 16, 65535); exchangeLR.call(this, 4, 252645135); M[offset] = this._lBlock; M[offset + 1] = this._rBlock }, keySize: 64 / 32, ivSize: 64 / 32, blockSize: 64 / 32 }); function exchangeLR (offset, mask) { var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask; this._rBlock ^= t; this._lBlock ^= t << offset } function exchangeRL (offset, mask) { var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask; this._lBlock ^= t; this._rBlock ^= t << offset } C.DES = BlockCipher._createHelper(DES); var TripleDES = C_algo.TripleDES = BlockCipher.extend({ _doReset: function () { var key = this._key; var keyWords = key.words; this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2))); this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4))); this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6))) }, encryptBlock: function (M, offset) { this._des1.encryptBlock(M, offset); this._des2.decryptBlock(M, offset); this._des3.encryptBlock(M, offset) }, decryptBlock: function (M, offset) { this._des3.decryptBlock(M, offset); this._des2.encryptBlock(M, offset); this._des1.decryptBlock(M, offset) }, keySize: 192 / 32, ivSize: 64 / 32, blockSize: 64 / 32 }); C.TripleDES = BlockCipher._createHelper(TripleDES) }()); return CryptoJS.TripleDES })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10), __webpack_require__(11), __webpack_require__(21), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var StreamCipher = C_lib.StreamCipher; var C_algo = C.algo; var RC4 = C_algo.RC4 = StreamCipher.extend({ _doReset: function () { var key = this._key; var keyWords = key.words; var keySigBytes = key.sigBytes; var S = this._S = []; for (var i = 0;i < 256;i++) { S[i] = i } for (var i = 0, j = 0;i < 256;i++) { var keyByteIndex = i % keySigBytes; var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 255; j = (j + S[i] + keyByte) % 256; var t = S[i]; S[i] = S[j]; S[j] = t } this._i = this._j = 0 }, _doProcessBlock: function (M, offset) { M[offset] ^= generateKeystreamWord.call(this) }, keySize: 256 / 32, ivSize: 0 }); function generateKeystreamWord () { var S = this._S; var i = this._i; var j = this._j; var keystreamWord = 0; for (var n = 0;n < 4;n++) { i = (i + 1) % 256; j = (j + S[i]) % 256; var t = S[i]; S[i] = S[j]; S[j] = t; keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8) } this._i = i; this._j = j; return keystreamWord } C.RC4 = StreamCipher._createHelper(RC4); var RC4Drop = C_algo.RC4Drop = RC4.extend({ cfg: RC4.cfg.extend({ drop: 192 }), _doReset: function () { RC4._doReset.call(this); for (var i = this.cfg.drop;i > 0;i--) { generateKeystreamWord.call(this) } } }); C.RC4Drop = StreamCipher._createHelper(RC4Drop) }()); return CryptoJS.RC4 })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10), __webpack_require__(11), __webpack_require__(21), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var StreamCipher = C_lib.StreamCipher; var C_algo = C.algo; var S = []; var C_ = []; var G = []; var Rabbit = C_algo.Rabbit = StreamCipher.extend({ _doReset: function () { var K = this._key.words; var iv = this.cfg.iv; for (var i = 0;i < 4;i++) { K[i] = (((K[i] << 8) | (K[i] >>> 24)) & 16711935) | (((K[i] << 24) | (K[i] >>> 8)) & 4278255360) } var X = this._X = [K[0], (K[3] << 16) | (K[2] >>> 16), K[1], (K[0] << 16) | (K[3] >>> 16), K[2], (K[1] << 16) | (K[0] >>> 16), K[3], (K[2] << 16) | (K[1] >>> 16)]; var C = this._C = [(K[2] << 16) | (K[2] >>> 16), (K[0] & 4294901760) | (K[1] & 65535), (K[3] << 16) | (K[3] >>> 16), (K[1] & 4294901760) | (K[2] & 65535), (K[0] << 16) | (K[0] >>> 16), (K[2] & 4294901760) | (K[3] & 65535), (K[1] << 16) | (K[1] >>> 16), (K[3] & 4294901760) | (K[0] & 65535)]; this._b = 0; for (var i = 0;i < 4;i++) { nextState.call(this) } for (var i = 0;i < 8;i++) { C[i] ^= X[(i + 4) & 7] } if (iv) { var IV = iv.words; var IV_0 = IV[0]; var IV_1 = IV[1]; var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 16711935) | (((IV_0 << 24) | (IV_0 >>> 8)) & 4278255360); var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 16711935) | (((IV_1 << 24) | (IV_1 >>> 8)) & 4278255360); var i1 = (i0 >>> 16) | (i2 & 4294901760); var i3 = (i2 << 16) | (i0 & 65535); C[0] ^= i0; C[1] ^= i1; C[2] ^= i2; C[3] ^= i3; C[4] ^= i0; C[5] ^= i1; C[6] ^= i2; C[7] ^= i3; for (var i = 0;i < 4;i++) { nextState.call(this) } } }, _doProcessBlock: function (M, offset) { var X = this._X; nextState.call(this); S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16); S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16); S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16); S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16); for (var i = 0;i < 4;i++) { S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 16711935) | (((S[i] << 24) | (S[i] >>> 8)) & 4278255360); M[offset + i] ^= S[i] } }, blockSize: 128 / 32, ivSize: 64 / 32 }); function nextState () { var X = this._X; var C = this._C; for (var i = 0;i < 8;i++) { C_[i] = C[i] } C[0] = (C[0] + 1295307597 + this._b) | 0; C[1] = (C[1] + 3545052371 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0; C[2] = (C[2] + 886263092 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0; C[3] = (C[3] + 1295307597 + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0; C[4] = (C[4] + 3545052371 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0; C[5] = (C[5] + 886263092 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0; C[6] = (C[6] + 1295307597 + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0; C[7] = (C[7] + 3545052371 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0; this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0; for (var i = 0;i < 8;i++) { var gx = X[i] + C[i]; var ga = gx & 65535; var gb = gx >>> 16; var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb; var gl = (((gx & 4294901760) * gx) | 0) + (((gx & 65535) * gx) | 0); G[i] = gh ^ gl } X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0; X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0; X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0; X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0; X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0; X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0; X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0; X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0 } C.Rabbit = StreamCipher._createHelper(Rabbit) }()); return CryptoJS.Rabbit })) }), (function (module, exports, __webpack_require__) { (function (root, factory, undef) { if (true) { module.exports = exports = factory(__webpack_require__(6), __webpack_require__(10), __webpack_require__(11), __webpack_require__(21), __webpack_require__(22)) } else { if (typeof define === "function" && define.amd) { define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory) } else { factory(root.CryptoJS) } } }(this, function (CryptoJS) { (function () { var C = CryptoJS; var C_lib = C.lib; var StreamCipher = C_lib.StreamCipher; var C_algo = C.algo; var S = []; var C_ = []; var G = []; var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({ _doReset: function () { var K = this._key.words; var iv = this.cfg.iv; var X = this._X = [K[0], (K[3] << 16) | (K[2] >>> 16), K[1], (K[0] << 16) | (K[3] >>> 16), K[2], (K[1] << 16) | (K[0] >>> 16), K[3], (K[2] << 16) | (K[1] >>> 16)]; var C = this._C = [(K[2] << 16) | (K[2] >>> 16), (K[0] & 4294901760) | (K[1] & 65535), (K[3] << 16) | (K[3] >>> 16), (K[1] & 4294901760) | (K[2] & 65535), (K[0] << 16) | (K[0] >>> 16), (K[2] & 4294901760) | (K[3] & 65535), (K[1] << 16) | (K[1] >>> 16), (K[3] & 4294901760) | (K[0] & 65535)]; this._b = 0; for (var i = 0;i < 4;i++) { nextState.call(this) } for (var i = 0;i < 8;i++) { C[i] ^= X[(i + 4) & 7] } if (iv) { var IV = iv.words; var IV_0 = IV[0]; var IV_1 = IV[1]; var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 16711935) | (((IV_0 << 24) | (IV_0 >>> 8)) & 4278255360); var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 16711935) | (((IV_1 << 24) | (IV_1 >>> 8)) & 4278255360); var i1 = (i0 >>> 16) | (i2 & 4294901760); var i3 = (i2 << 16) | (i0 & 65535); C[0] ^= i0; C[1] ^= i1; C[2] ^= i2; C[3] ^= i3; C[4] ^= i0; C[5] ^= i1; C[6] ^= i2; C[7] ^= i3; for (var i = 0;i < 4;i++) { nextState.call(this) } } }, _doProcessBlock: function (M, offset) { var X = this._X; nextState.call(this); S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16); S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16); S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16); S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16); for (var i = 0;i < 4;i++) { S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 16711935) | (((S[i] << 24) | (S[i] >>> 8)) & 4278255360); M[offset + i] ^= S[i] } }, blockSize: 128 / 32, ivSize: 64 / 32 }); function nextState () { var X = this._X; var C = this._C; for (var i = 0;i < 8;i++) { C_[i] = C[i] } C[0] = (C[0] + 1295307597 + this._b) | 0; C[1] = (C[1] + 3545052371 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0; C[2] = (C[2] + 886263092 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0; C[3] = (C[3] + 1295307597 + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0; C[4] = (C[4] + 3545052371 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0; C[5] = (C[5] + 886263092 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0; C[6] = (C[6] + 1295307597 + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0; C[7] = (C[7] + 3545052371 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0; this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0; for (var i = 0;i < 8;i++) { var gx = X[i] + C[i]; var ga = gx & 65535; var gb = gx >>> 16; var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb; var gl = (((gx & 4294901760) * gx) | 0) + (((gx & 65535) * gx) | 0); G[i] = gh ^ gl } X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0; X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0; X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0; X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0; X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0; X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0; X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0; X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0 } C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy) }()); return CryptoJS.RabbitLegacy })) }), (function (module, exports) { (function () { function Array_h (length) { this.array = length === undefined ? [] : new Array(length) } Array_h.prototype = { length: function () { return this.array.length }, at: function (index) { return this.array[index] }, set: function (index, obj) { this.array[index] = obj }, push: function (obj) { return this.array.push(obj) }, slice: function (start, end) { return this.array = this.array.slice(start, end) }, concat: function (array) { this.array = this.array.concat(array) }, remove: function (index, count) { count = count === undefined ? 1 : count; this.array.splice(index, count) }, join: function (separator) { return this.array.join(separator) }, clear: function () { this.array.length = 0 } }; var Queue = function () { this._array_h = new Array_h() }; Queue.prototype = { _index: 0, push: function (obj) { this._array_h.push(obj) }, pop: function () { var ret = null; if (this._array_h.length()) { ret = this._array_h.at(this._index); if (++this._index * 2 >= this._array_h.length()) { this._array_h.slice(this._index); this._index = 0 } } return ret }, head: function () { var ret = null, len = this._array_h.length(); if (len) { ret = this._array_h.at(len - 1) } return ret }, tail: function () { var ret = null, len = this._array_h.length(); if (len) { ret = this._array_h.at(this._index) } return ret }, length: function () { return this._array_h.length() - this._index }, empty: function () { return (this._array_h.length() === 0) }, clear: function () { this._array_h.clear() } }; exports.Queue = Queue }()) }), (function (module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; (function (global, module) { (function () { var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || this || {}; var previousUnderscore = root._; var ArrayProto = Array.prototype, ObjProto = Object.prototype; var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null; var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty; var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create; var Ctor = function () { }; var _ = function (obj) { if (obj instanceof _) { return obj } if (!(this instanceof _)) { return new _(obj) } this._wrapped = obj }; if (typeof exports != "undefined" && !exports.nodeType) { if (typeof module != "undefined" && !module.nodeType && module.exports) { exports = module.exports = _ } exports._ = _ } else { root._ = _ } _.VERSION = "1.9.1"; var optimizeCb = function (func, context, argCount) { if (context === void 0) { return func } switch (argCount == null ? 3 : argCount) { case 1: return function (value) { return func.call(context, value) }; case 3: return function (value, index, collection) { return func.call(context, value, index, collection) }; case 4: return function (accumulator, value, index, collection) { return func.call(context, accumulator, value, index, collection) } }return function () { return func.apply(context, arguments) } }; var builtinIteratee; var cb = function (value, context, argCount) { if (_.iteratee !== builtinIteratee) { return _.iteratee(value, context) } if (value == null) { return _.identity } if (_.isFunction(value)) { return optimizeCb(value, context, argCount) } if (_.isObject(value) && !_.isArray(value)) { return _.matcher(value) } return _.property(value) }; _.iteratee = builtinIteratee = function (value, context) { return cb(value, context, Infinity) }; var restArguments = function (func, startIndex) { startIndex = startIndex == null ? func.length - 1 : +startIndex; return function () { var length = Math.max(arguments.length - startIndex, 0), rest = Array(length), index = 0; for (;index < length;index++) { rest[index] = arguments[index + startIndex] } switch (startIndex) { case 0: return func.call(this, rest); case 1: return func.call(this, arguments[0], rest); case 2: return func.call(this, arguments[0], arguments[1], rest) }var args = Array(startIndex + 1); for (index = 0;index < startIndex;index++) { args[index] = arguments[index] } args[startIndex] = rest; return func.apply(this, args) } }; var baseCreate = function (prototype) { if (!_.isObject(prototype)) { return {} } if (nativeCreate) { return nativeCreate(prototype) } Ctor.prototype = prototype; var result = new Ctor; Ctor.prototype = null; return result }; var shallowProperty = function (key) { return function (obj) { return obj == null ? void 0 : obj[key] } }; var has = function (obj, path) { return obj != null && hasOwnProperty.call(obj, path) }; var deepGet = function (obj, path) { var length = path.length; for (var i = 0;i < length;i++) { if (obj == null) { return void 0 } obj = obj[path[i]] } return length ? obj : void 0 }; var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1; var getLength = shallowProperty("length"); var isArrayLike = function (collection) { var length = getLength(collection); return typeof length == "number" && length >= 0 && length <= MAX_ARRAY_INDEX }; _.each = _.forEach = function (obj, iteratee, context) { iteratee = optimizeCb(iteratee, context); var i, length; if (isArrayLike(obj)) { for (i = 0, length = obj.length;i < length;i++) { iteratee(obj[i], i, obj) } } else { var keys = _.keys(obj); for (i = 0, length = keys.length;i < length;i++) { iteratee(obj[keys[i]], keys[i], obj) } } return obj }; _.map = _.collect = function (obj, iteratee, context) { iteratee = cb(iteratee, context); var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, results = Array(length); for (var index = 0;index < length;index++) { var currentKey = keys ? keys[index] : index; results[index] = iteratee(obj[currentKey], currentKey, obj) } return results }; var createReduce = function (dir) { var reducer = function (obj, iteratee, memo, initial) { var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length, index = dir > 0 ? 0 : length - 1; if (!initial) { memo = obj[keys ? keys[index] : index]; index += dir } for (;index >= 0 && index < length;index += dir) { var currentKey = keys ? keys[index] : index; memo = iteratee(memo, obj[currentKey], currentKey, obj) } return memo }; return function (obj, iteratee, memo, context) { var initial = arguments.length >= 3; return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial) } }; _.reduce = _.foldl = _.inject = createReduce(1); _.reduceRight = _.foldr = createReduce(-1); _.find = _.detect = function (obj, predicate, context) { var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey; var key = keyFinder(obj, predicate, context); if (key !== void 0 && key !== -1) { return obj[key] } }; _.filter = _.select = function (obj, predicate, context) { var results = []; predicate = cb(predicate, context); _.each(obj, function (value, index, list) { if (predicate(value, index, list)) { results.push(value) } }); return results }; _.reject = function (obj, predicate, context) { return _.filter(obj, _.negate(cb(predicate)), context) }; _.every = _.all = function (obj, predicate, context) { predicate = cb(predicate, context); var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length; for (var index = 0;index < length;index++) { var currentKey = keys ? keys[index] : index; if (!predicate(obj[currentKey], currentKey, obj)) { return false } } return true }; _.some = _.any = function (obj, predicate, context) { predicate = cb(predicate, context); var keys = !isArrayLike(obj) && _.keys(obj), length = (keys || obj).length; for (var index = 0;index < length;index++) { var currentKey = keys ? keys[index] : index; if (predicate(obj[currentKey], currentKey, obj)) { return true } } return false }; _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) { if (!isArrayLike(obj)) { obj = _.values(obj) } if (typeof fromIndex != "number" || guard) { fromIndex = 0 } return _.indexOf(obj, item, fromIndex) >= 0 }; _.invoke = restArguments(function (obj, path, args) { var contextPath, func; if (_.isFunction(path)) { func = path } else { if (_.isArray(path)) { contextPath = path.slice(0, -1); path = path[path.length - 1] } } return _.map(obj, function (context) { var method = func; if (!method) { if (contextPath && contextPath.length) { context = deepGet(context, contextPath) } if (context == null) { return void 0 } method = context[path] } return method == null ? method : method.apply(context, args) }) }); _.pluck = function (obj, key) { return _.map(obj, _.property(key)) }; _.where = function (obj, attrs) { return _.filter(obj, _.matcher(attrs)) }; _.findWhere = function (obj, attrs) { return _.find(obj, _.matcher(attrs)) }; _.max = function (obj, iteratee, context) { var result = -Infinity, lastComputed = -Infinity, value, computed; if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) { obj = isArrayLike(obj) ? obj : _.values(obj); for (var i = 0, length = obj.length;i < length;i++) { value = obj[i]; if (value != null && value > result) { result = value } } } else { iteratee = cb(iteratee, context); _.each(obj, function (v, index, list) { computed = iteratee(v, index, list); if (computed > lastComputed || computed === -Infinity && result === -Infinity) { result = v; lastComputed = computed } }) } return result }; _.min = function (obj, iteratee, context) { var result = Infinity, lastComputed = Infinity, value, computed; if (iteratee == null || typeof iteratee == "number" && typeof obj[0] != "object" && obj != null) { obj = isArrayLike(obj) ? obj : _.values(obj); for (var i = 0, length = obj.length;i < length;i++) { value = obj[i]; if (value != null && value < result) { result = value } } } else { iteratee = cb(iteratee, context); _.each(obj, function (v, index, list) { computed = iteratee(v, index, list); if (computed < lastComputed || computed === Infinity && result === Infinity) { result = v; lastComputed = computed } }) } return result }; _.shuffle = function (obj) { return _.sample(obj, Infinity) }; _.sample = function (obj, n, guard) { if (n == null || guard) { if (!isArrayLike(obj)) { obj = _.values(obj) } return obj[_.random(obj.length - 1)] } var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj); var length = getLength(sample); n = Math.max(Math.min(n, length), 0); var last = length - 1; for (var index = 0;index < n;index++) { var rand = _.random(index, last); var temp = sample[index]; sample[index] = sample[rand]; sample[rand] = temp } return sample.slice(0, n) }; _.sortBy = function (obj, iteratee, context) { var index = 0; iteratee = cb(iteratee, context); return _.pluck(_.map(obj, function (value, key, list) { return { value: value, index: index++, criteria: iteratee(value, key, list) } }).sort(function (left, right) { var a = left.criteria; var b = right.criteria; if (a !== b) { if (a > b || a === void 0) { return 1 } if (a < b || b === void 0) { return -1 } } return left.index - right.index }), "value") }; var group = function (behavior, partition) { return function (obj, iteratee, context) { var result = partition ? [[], []] : {}; iteratee = cb(iteratee, context); _.each(obj, function (value, index) { var key = iteratee(value, index, obj); behavior(result, value, key) }); return result } }; _.groupBy = group(function (result, value, key) { if (has(result, key)) { result[key].push(value) } else { result[key] = [value] } }); _.indexBy = group(function (result, value, key) { result[key] = value }); _.countBy = group(function (result, value, key) { if (has(result, key)) { result[key]++ } else { result[key] = 1 } }); var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g; _.toArray = function (obj) { if (!obj) { return [] } if (_.isArray(obj)) { return slice.call(obj) } if (_.isString(obj)) { return obj.match(reStrSymbol) } if (isArrayLike(obj)) { return _.map(obj, _.identity) } return _.values(obj) }; _.size = function (obj) { if (obj == null) { return 0 } return isArrayLike(obj) ? obj.length : _.keys(obj).length }; _.partition = group(function (result, value, pass) { result[pass ? 0 : 1].push(value) }, true); _.first = _.head = _.take = function (array, n, guard) { if (array == null || array.length < 1) { return n == null ? void 0 : [] } if (n == null || guard) { return array[0] } return _.initial(array, array.length - n) }; _.initial = function (array, n, guard) { return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n))) }; _.last = function (array, n, guard) { if (array == null || array.length < 1) { return n == null ? void 0 : [] } if (n == null || guard) { return array[array.length - 1] } return _.rest(array, Math.max(0, array.length - n)) }; _.rest = _.tail = _.drop = function (array, n, guard) { return slice.call(array, n == null || guard ? 1 : n) }; _.compact = function (array) { return _.filter(array, Boolean) }; var flatten = function (input, shallow, strict, output) { output = output || []; var idx = output.length; for (var i = 0, length = getLength(input);i < length;i++) { var value = input[i]; if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) { if (shallow) { var j = 0, len = value.length; while (j < len) { output[idx++] = value[j++] } } else { flatten(value, shallow, strict, output); idx = output.length } } else { if (!strict) { output[idx++] = value } } } return output }; _.flatten = function (array, shallow) { return flatten(array, shallow, false) }; _.without = restArguments(function (array, otherArrays) { return _.difference(array, otherArrays) }); _.uniq = _.unique = function (array, isSorted, iteratee, context) { if (!_.isBoolean(isSorted)) { context = iteratee; iteratee = isSorted; isSorted = false } if (iteratee != null) { iteratee = cb(iteratee, context) } var result = []; var seen = []; for (var i = 0, length = getLength(array);i < length;i++) { var value = array[i], computed = iteratee ? iteratee(value, i, array) : value; if (isSorted && !iteratee) { if (!i || seen !== computed) { result.push(value) } seen = computed } else { if (iteratee) { if (!_.contains(seen, computed)) { seen.push(computed); result.push(value) } } else { if (!_.contains(result, value)) { result.push(value) } } } } return result }; _.union = restArguments(function (arrays) { return _.uniq(flatten(arrays, true, true)) }); _.intersection = function (array) { var result = []; var argsLength = arguments.length; for (var i = 0, length = getLength(array);i < length;i++) { var item = array[i]; if (_.contains(result, item)) { continue } var j; for (j = 1;j < argsLength;j++) { if (!_.contains(arguments[j], item)) { break } } if (j === argsLength) { result.push(item) } } return result }; _.difference = restArguments(function (array, rest) { rest = flatten(rest, true, true); return _.filter(array, function (value) { return !_.contains(rest, value) }) }); _.unzip = function (array) { var length = array && _.max(array, getLength).length || 0; var result = Array(length); for (var index = 0;index < length;index++) { result[index] = _.pluck(array, index) } return result }; _.zip = restArguments(_.unzip); _.object = function (list, values) { var result = {}; for (var i = 0, length = getLength(list);i < length;i++) { if (values) { result[list[i]] = values[i] } else { result[list[i][0]] = list[i][1] } } return result }; var createPredicateIndexFinder = function (dir) { return function (array, predicate, context) { predicate = cb(predicate, context); var length = getLength(array); var index = dir > 0 ? 0 : length - 1; for (;index >= 0 && index < length;index += dir) { if (predicate(array[index], index, array)) { return index } } return -1 } }; _.findIndex = createPredicateIndexFinder(1); _.findLastIndex = createPredicateIndexFinder(-1); _.sortedIndex = function (array, obj, iteratee, context) { iteratee = cb(iteratee, context, 1); var value = iteratee(obj); var low = 0, high = getLength(array); while (low < high) { var mid = Math.floor((low + high) / 2); if (iteratee(array[mid]) < value) { low = mid + 1 } else { high = mid } } return low }; var createIndexFinder = function (dir, predicateFind, sortedIndex) { return function (array, item, idx) { var i = 0, length = getLength(array); if (typeof idx == "number") { if (dir > 0) { i = idx >= 0 ? idx : Math.max(idx + length, i) } else { length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1 } } else { if (sortedIndex && idx && length) { idx = sortedIndex(array, item); return array[idx] === item ? idx : -1 } } if (item !== item) { idx = predicateFind(slice.call(array, i, length), _.isNaN); return idx >= 0 ? idx + i : -1 } for (idx = dir > 0 ? i : length - 1;idx >= 0 && idx < length;idx += dir) { if (array[idx] === item) { return idx } } return -1 } }; _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex); _.lastIndexOf = createIndexFinder(-1, _.findLastIndex); _.range = function (start, stop, step) { if (stop == null) { stop = start || 0; start = 0 } if (!step) { step = stop < start ? -1 : 1 } var length = Math.max(Math.ceil((stop - start) / step), 0); var range = Array(length); for (var idx = 0;idx < length;idx++ , start += step) { range[idx] = start } return range }; _.chunk = function (array, count) { if (count == null || count < 1) { return [] } var result = []; var i = 0, length = array.length; while (i < length) { result.push(slice.call(array, i, i += count)) } return result }; var executeBound = function (sourceFunc, boundFunc, context, callingContext, args) { if (!(callingContext instanceof boundFunc)) { return sourceFunc.apply(context, args) } var self = baseCreate(sourceFunc.prototype); var result = sourceFunc.apply(self, args); if (_.isObject(result)) { return result } return self }; _.bind = restArguments(function (func, context, args) { if (!_.isFunction(func)) { throw new TypeError("Bind must be called on a function") } var bound = restArguments(function (callArgs) { return executeBound(func, bound, context, this, args.concat(callArgs)) }); return bound }); _.partial = restArguments(function (func, boundArgs) { var placeholder = _.partial.placeholder; var bound = function () { var position = 0, length = boundArgs.length; var args = Array(length); for (var i = 0;i < length;i++) { args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i] } while (position < arguments.length) { args.push(arguments[position++]) } return executeBound(func, bound, this, this, args) }; return bound }); _.partial.placeholder = _; _.bindAll = restArguments(function (obj, keys) { keys = flatten(keys, false, false); var index = keys.length; if (index < 1) { throw new Error("bindAll must be passed function names") } while (index--) { var key = keys[index]; obj[key] = _.bind(obj[key], obj) } }); _.memoize = function (func, hasher) { var memoize = function (key) { var cache = memoize.cache; var address = "" + (hasher ? hasher.apply(this, arguments) : key); if (!has(cache, address)) { cache[address] = func.apply(this, arguments) } return cache[address] }; memoize.cache = {}; return memoize }; _.delay = restArguments(function (func, wait, args) { return setTimeout(function () { return func.apply(null, args) }, wait) }); _.defer = _.partial(_.delay, _, 1); _.throttle = function (func, wait, options) { var timeout, context, args, result; var previous = 0; if (!options) { options = {} } var later = function () { previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) { context = args = null } }; var throttled = function () { var now = _.now(); if (!previous && options.leading === false) { previous = now } var remaining = wait - (now - previous); context = this; args = arguments; if (remaining <= 0 || remaining > wait) { if (timeout) { clearTimeout(timeout); timeout = null } previous = now; result = func.apply(context, args); if (!timeout) { context = args = null } } else { if (!timeout && options.trailing !== false) { timeout = setTimeout(later, remaining) } } return result }; throttled.cancel = function () { clearTimeout(timeout); previous = 0; timeout = context = args = null }; return throttled }; _.debounce = function (func, wait, immediate) { var timeout, result; var later = function (context, args) { timeout = null; if (args) { result = func.apply(context, args) } }; var debounced = restArguments(function (args) { if (timeout) { clearTimeout(timeout) } if (immediate) { var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) { result = func.apply(this, args) } } else { timeout = _.delay(later, wait, this, args) } return result }); debounced.cancel = function () { clearTimeout(timeout); timeout = null }; return debounced }; _.wrap = function (func, wrapper) { return _.partial(wrapper, func) }; _.negate = function (predicate) { return function () { return !predicate.apply(this, arguments) } }; _.compose = function () { var args = arguments; var start = args.length - 1; return function () { var i = start; var result = args[start].apply(this, arguments); while (i--) { result = args[i].call(this, result) } return result } }; _.after = function (times, func) { return function () { if (--times < 1) { return func.apply(this, arguments) } } }; _.before = function (times, func) { var memo; return function () { if (--times > 0) { memo = func.apply(this, arguments) } if (times <= 1) { func = null } return memo } }; _.once = _.partial(_.before, 2); _.restArguments = restArguments; var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString"); var nonEnumerableProps = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"]; var collectNonEnumProps = function (obj, keys) { var nonEnumIdx = nonEnumerableProps.length; var constructor = obj.constructor; var proto = _.isFunction(constructor) && constructor.prototype || ObjProto; var prop = "constructor"; if (has(obj, prop) && !_.contains(keys, prop)) { keys.push(prop) } while (nonEnumIdx--) { prop = nonEnumerableProps[nonEnumIdx]; if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) { keys.push(prop) } } }; _.keys = function (obj) { if (!_.isObject(obj)) { return [] } if (nativeKeys) { return nativeKeys(obj) } var keys = []; for (var key in obj) { if (has(obj, key)) { keys.push(key) } } if (hasEnumBug) { collectNonEnumProps(obj, keys) } return keys }; _.allKeys = function (obj) { if (!_.isObject(obj)) { return [] } var keys = []; for (var key in obj) { keys.push(key) } if (hasEnumBug) { collectNonEnumProps(obj, keys) } return keys }; _.values = function (obj) { var keys = _.keys(obj); var length = keys.length; var values = Array(length); for (var i = 0;i < length;i++) { values[i] = obj[keys[i]] } return values }; _.mapObject = function (obj, iteratee, context) { iteratee = cb(iteratee, context); var keys = _.keys(obj), length = keys.length, results = {}; for (var index = 0;index < length;index++) { var currentKey = keys[index]; results[currentKey] = iteratee(obj[currentKey], currentKey, obj) } return results }; _.pairs = function (obj) { var keys = _.keys(obj); var length = keys.length; var pairs = Array(length); for (var i = 0;i < length;i++) { pairs[i] = [keys[i], obj[keys[i]]] } return pairs }; _.invert = function (obj) { var result = {}; var keys = _.keys(obj); for (var i = 0, length = keys.length;i < length;i++) { result[obj[keys[i]]] = keys[i] } return result }; _.functions = _.methods = function (obj) { var names = []; for (var key in obj) { if (_.isFunction(obj[key])) { names.push(key) } } return names.sort() }; var createAssigner = function (keysFunc, defaults) { return function (obj) { var length = arguments.length; if (defaults) { obj = Object(obj) } if (length < 2 || obj == null) { return obj } for (var index = 1;index < length;index++) { var source = arguments[index], keys = keysFunc(source), l = keys.length; for (var i = 0;i < l;i++) { var key = keys[i]; if (!defaults || obj[key] === void 0) { obj[key] = source[key] } } } return obj } }; _.extend = createAssigner(_.allKeys); _.extendOwn = _.assign = createAssigner(_.keys); _.findKey = function (obj, predicate, context) { predicate = cb(predicate, context); var keys = _.keys(obj), key; for (var i = 0, length = keys.length;i < length;i++) { key = keys[i]; if (predicate(obj[key], key, obj)) { return key } } }; var keyInObj = function (value, key, obj) { return key in obj }; _.pick = restArguments(function (obj, keys) { var result = {}, iteratee = keys[0]; if (obj == null) { return result } if (_.isFunction(iteratee)) { if (keys.length > 1) { iteratee = optimizeCb(iteratee, keys[1]) } keys = _.allKeys(obj) } else { iteratee = keyInObj; keys = flatten(keys, false, false); obj = Object(obj) } for (var i = 0, length = keys.length;i < length;i++) { var key = keys[i]; var value = obj[key]; if (iteratee(value, key, obj)) { result[key] = value } } return result }); _.omit = restArguments(function (obj, keys) { var iteratee = keys[0], context; if (_.isFunction(iteratee)) { iteratee = _.negate(iteratee); if (keys.length > 1) { context = keys[1] } } else { keys = _.map(flatten(keys, false, false), String); iteratee = function (value, key) { return !_.contains(keys, key) } } return _.pick(obj, iteratee, context) }); _.defaults = createAssigner(_.allKeys, true); _.create = function (prototype, props) { var result = baseCreate(prototype); if (props) { _.extendOwn(result, props) } return result }; _.clone = function (obj) { if (!_.isObject(obj)) { return obj } return _.isArray(obj) ? obj.slice() : _.extend({}, obj) }; _.tap = function (obj, interceptor) { interceptor(obj); return obj }; _.isMatch = function (object, attrs) { var keys = _.keys(attrs), length = keys.length; if (object == null) { return !length } var obj = Object(object); for (var i = 0;i < length;i++) { var key = keys[i]; if (attrs[key] !== obj[key] || !(key in obj)) { return false } } return true }; var eq, deepEq; eq = function (a, b, aStack, bStack) { if (a === b) { return a !== 0 || 1 / a === 1 / b } if (a == null || b == null) { return false } if (a !== a) { return b !== b } var type = typeof a; if (type !== "function" && type !== "object" && typeof b != "object") { return false } return deepEq(a, b, aStack, bStack) }; deepEq = function (a, b, aStack, bStack) { if (a instanceof _) { a = a._wrapped } if (b instanceof _) { b = b._wrapped } var className = toString.call(a); if (className !== toString.call(b)) { return false } switch (className) { case "[object RegExp]": case "[object String]": return "" + a === "" + b; case "[object Number]": if (+a !== +a) { return +b !== +b } return +a === 0 ? 1 / +a === 1 / b : +a === +b; case "[object Date]": case "[object Boolean]": return +a === +b; case "[object Symbol]": return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b) }var areArrays = className === "[object Array]"; if (!areArrays) { if (typeof a != "object" || typeof b != "object") { return false } var aCtor = a.constructor, bCtor = b.constructor; if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) { return false } } aStack = aStack || []; bStack = bStack || []; var length = aStack.length; while (length--) { if (aStack[length] === a) { return bStack[length] === b } } aStack.push(a); bStack.push(b); if (areArrays) { length = a.length; if (length !== b.length) { return false } while (length--) { if (!eq(a[length], b[length], aStack, bStack)) { return false } } } else { var keys = _.keys(a), key; length = keys.length; if (_.keys(b).length !== length) { return false } while (length--) { key = keys[length]; if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) { return false } } } aStack.pop(); bStack.pop(); return true }; _.isEqual = function (a, b) { return eq(a, b) }; _.isEmpty = function (obj) { if (obj == null) { return true } if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) { return obj.length === 0 } return _.keys(obj).length === 0 }; _.isElement = function (obj) { return !!(obj && obj.nodeType === 1) }; _.isArray = nativeIsArray || function (obj) { return toString.call(obj) === "[object Array]" }; _.isObject = function (obj) { var type = typeof obj; return type === "function" || type === "object" && !!obj }; _.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error", "Symbol", "Map", "WeakMap", "Set", "WeakSet"], function (name) { _["is" + name] = function (obj) { return toString.call(obj) === "[object " + name + "]" } }); if (!_.isArguments(arguments)) { _.isArguments = function (obj) { return has(obj, "callee") } } var nodelist = root.document && root.document.childNodes; if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") { _.isFunction = function (obj) { return typeof obj == "function" || false } } _.isFinite = function (obj) { return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj)) }; _.isNaN = function (obj) { return _.isNumber(obj) && isNaN(obj) }; _.isBoolean = function (obj) { return obj === true || obj === false || toString.call(obj) === "[object Boolean]" }; _.isNull = function (obj) { return obj === null }; _.isUndefined = function (obj) { return obj === void 0 }; _.has = function (obj, path) { if (!_.isArray(path)) { return has(obj, path) } var length = path.length; for (var i = 0;i < length;i++) { var key = path[i]; if (obj == null || !hasOwnProperty.call(obj, key)) { return false } obj = obj[key] } return !!length }; _.noConflict = function () { root._ = previousUnderscore; return this }; _.identity = function (value) { return value }; _.constant = function (value) { return function () { return value } }; _.noop = function () { }; _.property = function (path) { if (!_.isArray(path)) { return shallowProperty(path) } return function (obj) { return deepGet(obj, path) } }; _.propertyOf = function (obj) { if (obj == null) { return function () { } } return function (path) { return !_.isArray(path) ? obj[path] : deepGet(obj, path) } }; _.matcher = _.matches = function (attrs) { attrs = _.extendOwn({}, attrs); return function (obj) { return _.isMatch(obj, attrs) } }; _.times = function (n, iteratee, context) { var accum = Array(Math.max(0, n)); iteratee = optimizeCb(iteratee, context, 1); for (var i = 0;i < n;i++) { accum[i] = iteratee(i) } return accum }; _.random = function (min, max) { if (max == null) { max = min; min = 0 } return min + Math.floor(Math.random() * (max - min + 1)) }; _.now = Date.now || function () { return new Date().getTime() }; var escapeMap = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" }; var unescapeMap = _.invert(escapeMap); var createEscaper = function (map) { var escaper = function (match) { return map[match] }; var source = "(?:" + _.keys(map).join("|") + ")"; var testRegexp = RegExp(source); var replaceRegexp = RegExp(source, "g"); return function (string) { string = string == null ? "" : "" + string; return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string } }; _.escape = createEscaper(escapeMap); _.unescape = createEscaper(unescapeMap); _.result = function (obj, path, fallback) { if (!_.isArray(path)) { path = [path] } var length = path.length; if (!length) { return _.isFunction(fallback) ? fallback.call(obj) : fallback } for (var i = 0;i < length;i++) { var prop = obj == null ? void 0 : obj[path[i]]; if (prop === void 0) { prop = fallback; i = length } obj = _.isFunction(prop) ? prop.call(obj) : prop } return obj }; var idCounter = 0; _.uniqueId = function (prefix) { var id = ++idCounter + ""; return prefix ? prefix + id : id }; _.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }; var noMatch = /(.)^/; var escapes = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" }; var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g; var escapeChar = function (match) { return "\\" + escapes[match] }; _.template = function (text, settings, oldSettings) { if (!settings && oldSettings) { settings = oldSettings } settings = _.defaults({}, settings, _.templateSettings); var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join("|") + "|$", "g"); var index = 0; var source = "__p+='"; text.replace(matcher, function (match, escape, interpolate, evaluate, offset) { source += text.slice(index, offset).replace(escapeRegExp, escapeChar); index = offset + match.length; if (escape) { source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" } else { if (interpolate) { source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" } else { if (evaluate) { source += "';\n" + evaluate + "\n__p+='" } } } return match }); source += "';\n"; if (!settings.variable) { source = "with(obj||{}){\n" + source + "}\n" } source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n"; var render; try { render = new Function(settings.variable || "obj", "_", source) } catch (e) { e.source = source; throw e } var template = function (data) { return render.call(this, data, _) }; var argument = settings.variable || "obj"; template.source = "function(" + argument + "){\n" + source + "}"; return template }; _.chain = function (obj) { var instance = _(obj); instance._chain = true; return instance }; var chainResult = function (instance, obj) { return instance._chain ? _(obj).chain() : obj }; _.mixin = function (obj) { _.each(_.functions(obj), function (name) { var func = _[name] = obj[name]; _.prototype[name] = function () { var args = [this._wrapped]; push.apply(args, arguments); return chainResult(this, func.apply(_, args)) } }); return _ }; _.mixin(_); _.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (name) { var method = ArrayProto[name]; _.prototype[name] = function () { var obj = this._wrapped; method.apply(obj, arguments); if ((name === "shift" || name === "splice") && obj.length === 0) { delete obj[0] } return chainResult(this, obj) } }); _.each(["concat", "join", "slice"], function (name) { var method = ArrayProto[name]; _.prototype[name] = function () { return chainResult(this, method.apply(this._wrapped, arguments)) } }); _.prototype.value = function () { return this._wrapped }; _.prototype.valueOf = _.prototype.toJSON = _.prototype.value; _.prototype.toString = function () { return String(this._wrapped) }; if (true) { !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return _ }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) } }()) }.call(exports, (function () { return this }()), __webpack_require__(41)(module))) }), (function (module, exports) { module.exports = function (module) { if (!module.webpackPolyfill) { module.deprecate = function () { }; module.paths = []; module.children = []; module.webpackPolyfill = 1 } return module } })]) });
